From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Quim Muntal <qmuntaldiaz@microsoft.com>
Date: Mon, 23 May 2022 12:59:07 +0000
Subject: [PATCH] Integrate OpenSSL module

---
 src/cmd/api/goapi_boring_test.go          |   2 +-
 src/cmd/go/go_boring_test.go              |   2 +-
 src/cmd/link/internal/ld/lib.go           |   1 +
 src/crypto/aes/cipher.go                  |   2 +-
 src/crypto/aes/cipher_asm.go              |   2 +-
 src/crypto/boring/boring.go               |   4 +-
 src/crypto/ecdsa/boring.go                |  11 +-
 src/crypto/ecdsa/ecdsa.go                 |   4 +-
 src/crypto/ecdsa/notboring.go             |   4 +-
 src/crypto/ed25519/ed25519_test.go        |   2 +-
 src/crypto/hmac/hmac.go                   |   2 +-
 src/crypto/hmac/hmac_test.go              |   2 +-
 src/crypto/internal/boring/cache.go       | 140 ----------------------
 src/crypto/internal/boring/cache_test.go  | 120 -------------------
 src/crypto/internal/boring/fipstls/stub.s |   2 +-
 src/crypto/internal/boring/fipstls/tls.go |   2 +-
 src/crypto/rand/rand_unix.go              |   2 +-
 src/crypto/rsa/boring.go                  |  11 +-
 src/crypto/rsa/boring_test.go             |   2 +-
 src/crypto/rsa/notboring.go               |   4 +-
 src/crypto/rsa/pkcs1v15.go                |   2 +-
 src/crypto/rsa/pss.go                     |   2 +-
 src/crypto/rsa/rsa.go                     |   4 +-
 src/crypto/rsa/rsa_test.go                |   2 +-
 src/crypto/sha1/boring.go                 |   4 +-
 src/crypto/sha1/sha1_test.go              |   2 +-
 src/crypto/sha256/sha256.go               |   2 +-
 src/crypto/sha256/sha256_test.go          |   2 +-
 src/crypto/sha512/sha512.go               |   2 +-
 src/crypto/sha512/sha512_test.go          |   2 +-
 src/crypto/tls/boring.go                  |   2 +-
 src/crypto/tls/boring_test.go             |   2 +-
 src/crypto/tls/cipher_suites.go           |   2 +-
 src/crypto/tls/fipsonly/fipsonly.go       |   2 +-
 src/crypto/tls/fipsonly/fipsonly_test.go  |   2 +-
 src/crypto/tls/notboring.go               |   2 +-
 src/crypto/x509/boring.go                 |   2 +-
 src/crypto/x509/boring_test.go            |   2 +-
 src/crypto/x509/notboring.go              |   2 +-
 src/runtime/mgc.go                        |   4 +-
 40 files changed, 55 insertions(+), 312 deletions(-)
 delete mode 100644 src/crypto/internal/boring/cache.go
 delete mode 100644 src/crypto/internal/boring/cache_test.go

diff --git a/src/cmd/api/goapi_boring_test.go b/src/cmd/api/goapi_boring_test.go
index f0e3575637c..0e9aceeb832 100644
--- a/src/cmd/api/goapi_boring_test.go
+++ b/src/cmd/api/goapi_boring_test.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto
+//go:build boringcrypto || goexperiment.opensslcrypto
 
 package main
 
diff --git a/src/cmd/go/go_boring_test.go b/src/cmd/go/go_boring_test.go
index ed0fbf3d53d..5376227f74c 100644
--- a/src/cmd/go/go_boring_test.go
+++ b/src/cmd/go/go_boring_test.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto
+//go:build boringcrypto || goexperiment.opensslcrypto
 
 package main_test
 
diff --git a/src/cmd/link/internal/ld/lib.go b/src/cmd/link/internal/ld/lib.go
index 04b2556ea1e..6546123f87f 100644
--- a/src/cmd/link/internal/ld/lib.go
+++ b/src/cmd/link/internal/ld/lib.go
@@ -1059,6 +1059,7 @@ var hostobj []Hostobj
 // These packages can use internal linking mode.
 // Others trigger external mode.
 var internalpkg = []string{
+	"vendor/github.com/microsoft/go-crypto-openssl/openssl",
 	"crypto/internal/boring",
 	"crypto/internal/boring/syso",
 	"crypto/x509",
diff --git a/src/crypto/aes/cipher.go b/src/crypto/aes/cipher.go
index 29d01796eb3..f3680ad6b43 100644
--- a/src/crypto/aes/cipher.go
+++ b/src/crypto/aes/cipher.go
@@ -10,7 +10,7 @@ import (
 	"strconv"
 )
 
-import "crypto/internal/boring"
+import boring "crypto/internal/backend"
 
 // The AES block size in bytes.
 const BlockSize = 16
diff --git a/src/crypto/aes/cipher_asm.go b/src/crypto/aes/cipher_asm.go
index b7e59d7edb6..994749c10c8 100644
--- a/src/crypto/aes/cipher_asm.go
+++ b/src/crypto/aes/cipher_asm.go
@@ -13,7 +13,7 @@ import (
 	"internal/goarch"
 )
 
-import "crypto/internal/boring"
+import boring "crypto/internal/backend"
 
 // defined in asm_*.s
 
diff --git a/src/crypto/boring/boring.go b/src/crypto/boring/boring.go
index 097c37e343f..7b04f14ebdd 100644
--- a/src/crypto/boring/boring.go
+++ b/src/crypto/boring/boring.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto
+//go:build boringcrypto || goexperiment.opensslcrypto
 
 // Package boring exposes functions that are only available when building with
 // Go+BoringCrypto. This package is available on all targets as long as the
@@ -13,7 +13,7 @@
 // is satisfied, so that applications can tag files that use this package.
 package boring
 
-import "crypto/internal/boring"
+import boring "crypto/internal/backend"
 
 // Enabled reports whether BoringCrypto handles supported crypto operations.
 func Enabled() bool {
diff --git a/src/crypto/ecdsa/boring.go b/src/crypto/ecdsa/boring.go
index edb723fe0ee..c98044d38ca 100644
--- a/src/crypto/ecdsa/boring.go
+++ b/src/crypto/ecdsa/boring.go
@@ -2,13 +2,14 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto
+//go:build boringcrypto || goexperiment.opensslcrypto
 
 package ecdsa
 
 import (
-	"crypto/internal/boring"
-	"crypto/internal/boring/bbig"
+	boring "crypto/internal/backend"
+	"crypto/internal/backend/bbig"
+	"crypto/internal/backend/bcache"
 	"math/big"
 	"unsafe"
 )
@@ -26,8 +27,8 @@ import (
 // still matches before using the cached key. The theory is that the real
 // operations are significantly more expensive than the comparison.
 
-var pubCache boring.Cache
-var privCache boring.Cache
+var pubCache bcache.Cache
+var privCache bcache.Cache
 
 func init() {
 	pubCache.Register()
diff --git a/src/crypto/ecdsa/ecdsa.go b/src/crypto/ecdsa/ecdsa.go
index 7ce7542872c..e12e8410eee 100644
--- a/src/crypto/ecdsa/ecdsa.go
+++ b/src/crypto/ecdsa/ecdsa.go
@@ -24,14 +24,14 @@ import (
 	"crypto/aes"
 	"crypto/cipher"
 	"crypto/elliptic"
-	"crypto/internal/boring/bbig"
+	"crypto/internal/backend/bbig"
 	"crypto/internal/randutil"
 	"crypto/sha512"
 	"errors"
 	"io"
 	"math/big"
 
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 
 	"golang.org/x/crypto/cryptobyte"
 	"golang.org/x/crypto/cryptobyte/asn1"
diff --git a/src/crypto/ecdsa/notboring.go b/src/crypto/ecdsa/notboring.go
index 039bd82ed21..3cc16ecab56 100644
--- a/src/crypto/ecdsa/notboring.go
+++ b/src/crypto/ecdsa/notboring.go
@@ -2,11 +2,11 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build !boringcrypto
+//go:build !boringcrypto && !goexperiment.opensslcrypto
 
 package ecdsa
 
-import "crypto/internal/boring"
+import boring "crypto/internal/backend"
 
 func boringPublicKey(*PublicKey) (*boring.PublicKeyECDSA, error) {
 	panic("boringcrypto: not available")
diff --git a/src/crypto/ed25519/ed25519_test.go b/src/crypto/ed25519/ed25519_test.go
index 7c5181788f6..bf29780070c 100644
--- a/src/crypto/ed25519/ed25519_test.go
+++ b/src/crypto/ed25519/ed25519_test.go
@@ -9,7 +9,7 @@ import (
 	"bytes"
 	"compress/gzip"
 	"crypto"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/rand"
 	"encoding/hex"
 	"os"
diff --git a/src/crypto/hmac/hmac.go b/src/crypto/hmac/hmac.go
index 34805765d55..79fd58d0da4 100644
--- a/src/crypto/hmac/hmac.go
+++ b/src/crypto/hmac/hmac.go
@@ -26,7 +26,7 @@ import (
 	"hash"
 )
 
-import "crypto/internal/boring"
+import boring "crypto/internal/backend"
 
 // FIPS 198-1:
 // https://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf
diff --git a/src/crypto/hmac/hmac_test.go b/src/crypto/hmac/hmac_test.go
index 55415abf020..904925377bb 100644
--- a/src/crypto/hmac/hmac_test.go
+++ b/src/crypto/hmac/hmac_test.go
@@ -6,7 +6,7 @@ package hmac
 
 import (
 	"bytes"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/md5"
 	"crypto/sha1"
 	"crypto/sha256"
diff --git a/src/crypto/internal/boring/cache.go b/src/crypto/internal/boring/cache.go
deleted file mode 100644
index 476e47706c9..00000000000
--- a/src/crypto/internal/boring/cache.go
+++ /dev/null
@@ -1,140 +0,0 @@
-// Copyright 2022 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package boring
-
-import (
-	"sync/atomic"
-	"unsafe"
-)
-
-// A Cache is a GC-friendly concurrent map from unsafe.Pointer to
-// unsafe.Pointer. It is meant to be used for maintaining shadow
-// BoringCrypto state associated with certain allocated structs, in
-// particular public and private RSA and ECDSA keys.
-//
-// The cache is GC-friendly in the sense that the keys do not
-// indefinitely prevent the garbage collector from collecting them.
-// Instead, at the start of each GC, the cache is cleared entirely. That
-// is, the cache is lossy, and the loss happens at the start of each GC.
-// This means that clients need to be able to cope with cache entries
-// disappearing, but it also means that clients don't need to worry about
-// cache entries keeping the keys from being collected.
-//
-// TODO(rsc): Make Cache generic once consumers can handle that.
-type Cache struct {
-	// ptable is an atomic *[cacheSize]unsafe.Pointer,
-	// where each unsafe.Pointer is an atomic *cacheEntry.
-	// The runtime atomically stores nil to ptable at the start of each GC.
-	ptable unsafe.Pointer
-}
-
-// A cacheEntry is a single entry in the linked list for a given hash table entry.
-type cacheEntry struct {
-	k    unsafe.Pointer // immutable once created
-	v    unsafe.Pointer // read and written atomically to allow updates
-	next *cacheEntry    // immutable once linked into table
-}
-
-func registerCache(unsafe.Pointer) // provided by runtime
-
-// Register registers the cache with the runtime,
-// so that c.ptable can be cleared at the start of each GC.
-// Register must be called during package initialization.
-func (c *Cache) Register() {
-	registerCache(unsafe.Pointer(&c.ptable))
-}
-
-// cacheSize is the number of entries in the hash table.
-// The hash is the pointer value mod cacheSize, a prime.
-// Collisions are resolved by maintaining a linked list in each hash slot.
-const cacheSize = 1021
-
-// table returns a pointer to the current cache hash table,
-// coping with the possibility of the GC clearing it out from under us.
-func (c *Cache) table() *[cacheSize]unsafe.Pointer {
-	for {
-		p := atomic.LoadPointer(&c.ptable)
-		if p == nil {
-			p = unsafe.Pointer(new([cacheSize]unsafe.Pointer))
-			if !atomic.CompareAndSwapPointer(&c.ptable, nil, p) {
-				continue
-			}
-		}
-		return (*[cacheSize]unsafe.Pointer)(p)
-	}
-}
-
-// Clear clears the cache.
-// The runtime does this automatically at each garbage collection;
-// this method is exposed only for testing.
-func (c *Cache) Clear() {
-	// The runtime does this at the start of every garbage collection
-	// (itself, not by calling this function).
-	atomic.StorePointer(&c.ptable, nil)
-}
-
-// Get returns the cached value associated with v,
-// which is either the value v corresponding to the most recent call to Put(k, v)
-// or nil if that cache entry has been dropped.
-func (c *Cache) Get(k unsafe.Pointer) unsafe.Pointer {
-	head := &c.table()[uintptr(k)%cacheSize]
-	e := (*cacheEntry)(atomic.LoadPointer(head))
-	for ; e != nil; e = e.next {
-		if e.k == k {
-			return atomic.LoadPointer(&e.v)
-		}
-	}
-	return nil
-}
-
-// Put sets the cached value associated with k to v.
-func (c *Cache) Put(k, v unsafe.Pointer) {
-	head := &c.table()[uintptr(k)%cacheSize]
-
-	// Strategy is to walk the linked list at head,
-	// same as in Get, to look for existing entry.
-	// If we find one, we update v atomically in place.
-	// If not, then we race to replace the start = *head
-	// we observed with a new k, v entry.
-	// If we win that race, we're done.
-	// Otherwise, we try the whole thing again,
-	// with two optimizations:
-	//
-	//  1. We track in noK the start of the section of
-	//     the list that we've confirmed has no entry for k.
-	//     The next time down the list, we can stop at noK,
-	//     because new entries are inserted at the front of the list.
-	//     This guarantees we never traverse an entry
-	//     multiple times.
-	//
-	//  2. We only allocate the entry to be added once,
-	//     saving it in add for the next attempt.
-	var add, noK *cacheEntry
-	n := 0
-	for {
-		e := (*cacheEntry)(atomic.LoadPointer(head))
-		start := e
-		for ; e != nil && e != noK; e = e.next {
-			if e.k == k {
-				atomic.StorePointer(&e.v, v)
-				return
-			}
-			n++
-		}
-		if add == nil {
-			add = &cacheEntry{k, v, nil}
-		}
-		add.next = start
-		if n >= 1000 {
-			// If an individual list gets too long, which shouldn't happen,
-			// throw it away to avoid quadratic lookup behavior.
-			add.next = nil
-		}
-		if atomic.CompareAndSwapPointer(head, unsafe.Pointer(start), unsafe.Pointer(add)) {
-			return
-		}
-		noK = start
-	}
-}
diff --git a/src/crypto/internal/boring/cache_test.go b/src/crypto/internal/boring/cache_test.go
deleted file mode 100644
index f9ccb74f6fd..00000000000
--- a/src/crypto/internal/boring/cache_test.go
+++ /dev/null
@@ -1,120 +0,0 @@
-// Copyright 2022 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package boring
-
-import (
-	"fmt"
-	"runtime"
-	"sync"
-	"sync/atomic"
-	"testing"
-	"unsafe"
-)
-
-var registeredCache Cache
-
-func init() {
-	registeredCache.Register()
-}
-
-func TestCache(t *testing.T) {
-	// Use unregistered cache for functionality tests,
-	// to keep the runtime from clearing behind our backs.
-	c := new(Cache)
-
-	// Create many entries.
-	seq := uint32(0)
-	next := func() unsafe.Pointer {
-		x := new(int)
-		*x = int(atomic.AddUint32(&seq, 1))
-		return unsafe.Pointer(x)
-	}
-	m := make(map[unsafe.Pointer]unsafe.Pointer)
-	for i := 0; i < 10000; i++ {
-		k := next()
-		v := next()
-		m[k] = v
-		c.Put(k, v)
-	}
-
-	// Overwrite a random 20% of those.
-	n := 0
-	for k := range m {
-		v := next()
-		m[k] = v
-		c.Put(k, v)
-		if n++; n >= 2000 {
-			break
-		}
-	}
-
-	// Check results.
-	str := func(p unsafe.Pointer) string {
-		if p == nil {
-			return "nil"
-		}
-		return fmt.Sprint(*(*int)(p))
-	}
-	for k, v := range m {
-		if cv := c.Get(k); cv != v {
-			t.Fatalf("c.Get(%v) = %v, want %v", str(k), str(cv), str(v))
-		}
-	}
-
-	c.Clear()
-	for k := range m {
-		if cv := c.Get(k); cv != nil {
-			t.Fatalf("after GC, c.Get(%v) = %v, want nil", str(k), str(cv))
-		}
-	}
-
-	// Check that registered cache is cleared at GC.
-	c = &registeredCache
-	for k, v := range m {
-		c.Put(k, v)
-	}
-	runtime.GC()
-	for k := range m {
-		if cv := c.Get(k); cv != nil {
-			t.Fatalf("after Clear, c.Get(%v) = %v, want nil", str(k), str(cv))
-		}
-	}
-
-	// Check that cache works for concurrent access.
-	// Lists are discarded if they reach 1000 entries,
-	// and there are cacheSize list heads, so we should be
-	// able to do 100 * cacheSize entries with no problem at all.
-	c = new(Cache)
-	var barrier, wg sync.WaitGroup
-	const N = 100
-	barrier.Add(N)
-	wg.Add(N)
-	var lost int32
-	for i := 0; i < N; i++ {
-		go func() {
-			defer wg.Done()
-
-			m := make(map[unsafe.Pointer]unsafe.Pointer)
-			for j := 0; j < cacheSize; j++ {
-				k, v := next(), next()
-				m[k] = v
-				c.Put(k, v)
-			}
-			barrier.Done()
-			barrier.Wait()
-
-			for k, v := range m {
-				if cv := c.Get(k); cv != v {
-					t.Errorf("c.Get(%v) = %v, want %v", str(k), str(cv), str(v))
-					atomic.AddInt32(&lost, +1)
-				}
-			}
-		}()
-	}
-	wg.Wait()
-	if lost != 0 {
-		t.Errorf("lost %d entries", lost)
-	}
-}
diff --git a/src/crypto/internal/boring/fipstls/stub.s b/src/crypto/internal/boring/fipstls/stub.s
index f2e5a503eaa..1dc7116efdf 100644
--- a/src/crypto/internal/boring/fipstls/stub.s
+++ b/src/crypto/internal/boring/fipstls/stub.s
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto
+//go:build boringcrypto || goexperiment.opensslcrypto
 
 // runtime_arg0 is declared in tls.go without a body.
 // It's provided by package runtime,
diff --git a/src/crypto/internal/boring/fipstls/tls.go b/src/crypto/internal/boring/fipstls/tls.go
index 701700e4e3a..703df619b77 100644
--- a/src/crypto/internal/boring/fipstls/tls.go
+++ b/src/crypto/internal/boring/fipstls/tls.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto
+//go:build boringcrypto || goexperiment.opensslcrypto
 
 // Package fipstls allows control over whether crypto/tls requires FIPS-approved settings.
 // This package only exists with GOEXPERIMENT=boringcrypto, but the effects are independent
diff --git a/src/crypto/rand/rand_unix.go b/src/crypto/rand/rand_unix.go
index 830983c74ac..d293683a0c7 100644
--- a/src/crypto/rand/rand_unix.go
+++ b/src/crypto/rand/rand_unix.go
@@ -19,7 +19,7 @@ import (
 	"time"
 )
 
-import "crypto/internal/boring"
+import boring "crypto/internal/backend"
 
 const urandomDevice = "/dev/urandom"
 
diff --git a/src/crypto/rsa/boring.go b/src/crypto/rsa/boring.go
index fc2842fb341..5c6f44f2c9c 100644
--- a/src/crypto/rsa/boring.go
+++ b/src/crypto/rsa/boring.go
@@ -2,13 +2,14 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto
+//go:build boringcrypto || goexperiment.opensslcrypto
 
 package rsa
 
 import (
-	"crypto/internal/boring"
-	"crypto/internal/boring/bbig"
+	boring "crypto/internal/backend"
+	"crypto/internal/backend/bbig"
+	"crypto/internal/backend/bcache"
 	"math/big"
 	"unsafe"
 )
@@ -31,8 +32,8 @@ type boringPub struct {
 	orig PublicKey
 }
 
-var pubCache boring.Cache
-var privCache boring.Cache
+var pubCache bcache.Cache
+var privCache bcache.Cache
 
 func init() {
 	pubCache.Register()
diff --git a/src/crypto/rsa/boring_test.go b/src/crypto/rsa/boring_test.go
index 6223244283f..b8ecc1b50be 100644
--- a/src/crypto/rsa/boring_test.go
+++ b/src/crypto/rsa/boring_test.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto
+//go:build boringcrypto || goexperiment.opensslcrypto
 
 // Note: Can run these tests against the non-BoringCrypto
 // version of the code by using "CGO_ENABLED=0 go test".
diff --git a/src/crypto/rsa/notboring.go b/src/crypto/rsa/notboring.go
index 2abc0436405..933ac569e03 100644
--- a/src/crypto/rsa/notboring.go
+++ b/src/crypto/rsa/notboring.go
@@ -2,11 +2,11 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build !boringcrypto
+//go:build !boringcrypto && !goexperiment.opensslcrypto
 
 package rsa
 
-import "crypto/internal/boring"
+import boring "crypto/internal/backend"
 
 func boringPublicKey(*PublicKey) (*boring.PublicKeyRSA, error) {
 	panic("boringcrypto: not available")
diff --git a/src/crypto/rsa/pkcs1v15.go b/src/crypto/rsa/pkcs1v15.go
index 8cf3b6e255b..22a11207272 100644
--- a/src/crypto/rsa/pkcs1v15.go
+++ b/src/crypto/rsa/pkcs1v15.go
@@ -14,7 +14,7 @@ import (
 	"crypto/internal/randutil"
 )
 
-import "crypto/internal/boring"
+import boring "crypto/internal/backend"
 
 // This file implements encryption and decryption using PKCS #1 v1.5 padding.
 
diff --git a/src/crypto/rsa/pss.go b/src/crypto/rsa/pss.go
index 16ebc0e6a7f..54afa8992e9 100644
--- a/src/crypto/rsa/pss.go
+++ b/src/crypto/rsa/pss.go
@@ -15,7 +15,7 @@ import (
 	"math/big"
 )
 
-import "crypto/internal/boring"
+import boring "crypto/internal/backend"
 
 // Per RFC 8017, Section 9.1
 //
diff --git a/src/crypto/rsa/rsa.go b/src/crypto/rsa/rsa.go
index c941124fb26..5ef07fdbe9e 100644
--- a/src/crypto/rsa/rsa.go
+++ b/src/crypto/rsa/rsa.go
@@ -24,8 +24,8 @@ package rsa
 
 import (
 	"crypto"
-	"crypto/internal/boring"
-	"crypto/internal/boring/bbig"
+	boring "crypto/internal/backend"
+	"crypto/internal/backend/bbig"
 	"crypto/internal/randutil"
 	"crypto/rand"
 	"crypto/subtle"
diff --git a/src/crypto/rsa/rsa_test.go b/src/crypto/rsa/rsa_test.go
index 766d9a954f8..f2602b94ab8 100644
--- a/src/crypto/rsa/rsa_test.go
+++ b/src/crypto/rsa/rsa_test.go
@@ -15,7 +15,7 @@ import (
 	"testing"
 )
 
-import "crypto/internal/boring"
+import boring "crypto/internal/backend"
 
 func TestKeyGeneration(t *testing.T) {
 	for _, size := range []int{128, 1024, 2048, 3072} {
diff --git a/src/crypto/sha1/boring.go b/src/crypto/sha1/boring.go
index b5786d1bf4e..4aa5d04e8f9 100644
--- a/src/crypto/sha1/boring.go
+++ b/src/crypto/sha1/boring.go
@@ -12,11 +12,11 @@
 package sha1
 
 import (
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"hash"
 )
 
-const boringEnabled = boring.Enabled
+var boringEnabled = boring.Enabled
 
 func boringNewSHA1() hash.Hash { return boring.NewSHA1() }
 
diff --git a/src/crypto/sha1/sha1_test.go b/src/crypto/sha1/sha1_test.go
index 85ed1260915..bc169888786 100644
--- a/src/crypto/sha1/sha1_test.go
+++ b/src/crypto/sha1/sha1_test.go
@@ -8,7 +8,7 @@ package sha1
 
 import (
 	"bytes"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/rand"
 	"encoding"
 	"fmt"
diff --git a/src/crypto/sha256/sha256.go b/src/crypto/sha256/sha256.go
index e3c15e66ca3..e071a0fa2e6 100644
--- a/src/crypto/sha256/sha256.go
+++ b/src/crypto/sha256/sha256.go
@@ -8,7 +8,7 @@ package sha256
 
 import (
 	"crypto"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"encoding/binary"
 	"errors"
 	"hash"
diff --git a/src/crypto/sha256/sha256_test.go b/src/crypto/sha256/sha256_test.go
index 7304678346b..7437655bade 100644
--- a/src/crypto/sha256/sha256_test.go
+++ b/src/crypto/sha256/sha256_test.go
@@ -8,7 +8,7 @@ package sha256
 
 import (
 	"bytes"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/rand"
 	"encoding"
 	"fmt"
diff --git a/src/crypto/sha512/sha512.go b/src/crypto/sha512/sha512.go
index c800a294a27..008c0475459 100644
--- a/src/crypto/sha512/sha512.go
+++ b/src/crypto/sha512/sha512.go
@@ -12,7 +12,7 @@ package sha512
 
 import (
 	"crypto"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"encoding/binary"
 	"errors"
 	"hash"
diff --git a/src/crypto/sha512/sha512_test.go b/src/crypto/sha512/sha512_test.go
index 921cdbb7bbd..2fef7ddae07 100644
--- a/src/crypto/sha512/sha512_test.go
+++ b/src/crypto/sha512/sha512_test.go
@@ -8,7 +8,7 @@ package sha512
 
 import (
 	"bytes"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/rand"
 	"encoding"
 	"encoding/hex"
diff --git a/src/crypto/tls/boring.go b/src/crypto/tls/boring.go
index 1827f764589..70baa62d637 100644
--- a/src/crypto/tls/boring.go
+++ b/src/crypto/tls/boring.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto
+//go:build boringcrypto || goexperiment.opensslcrypto
 
 package tls
 
diff --git a/src/crypto/tls/boring_test.go b/src/crypto/tls/boring_test.go
index f743fc8e9fb..2131a76ca74 100644
--- a/src/crypto/tls/boring_test.go
+++ b/src/crypto/tls/boring_test.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto
+//go:build boringcrypto || goexperiment.opensslcrypto
 
 package tls
 
diff --git a/src/crypto/tls/cipher_suites.go b/src/crypto/tls/cipher_suites.go
index 3004b31698d..ce0a1426ead 100644
--- a/src/crypto/tls/cipher_suites.go
+++ b/src/crypto/tls/cipher_suites.go
@@ -4,7 +4,7 @@
 
 package tls
 
-import "crypto/internal/boring"
+import boring "crypto/internal/backend"
 
 import (
 	"crypto"
diff --git a/src/crypto/tls/fipsonly/fipsonly.go b/src/crypto/tls/fipsonly/fipsonly.go
index e5e47835e2f..1a94656dfee 100644
--- a/src/crypto/tls/fipsonly/fipsonly.go
+++ b/src/crypto/tls/fipsonly/fipsonly.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto
+//go:build boringcrypto || goexperiment.opensslcrypto
 
 // Package fipsonly restricts all TLS configuration to FIPS-approved settings.
 //
diff --git a/src/crypto/tls/fipsonly/fipsonly_test.go b/src/crypto/tls/fipsonly/fipsonly_test.go
index f8485dc3ca1..9c1d3d279c4 100644
--- a/src/crypto/tls/fipsonly/fipsonly_test.go
+++ b/src/crypto/tls/fipsonly/fipsonly_test.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto
+//go:build boringcrypto || goexperiment.opensslcrypto
 
 package fipsonly
 
diff --git a/src/crypto/tls/notboring.go b/src/crypto/tls/notboring.go
index 7d85b39c593..1aaabd5ef48 100644
--- a/src/crypto/tls/notboring.go
+++ b/src/crypto/tls/notboring.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build !boringcrypto
+//go:build !boringcrypto && !goexperiment.opensslcrypto
 
 package tls
 
diff --git a/src/crypto/x509/boring.go b/src/crypto/x509/boring.go
index 4aae90570d7..24add90c720 100644
--- a/src/crypto/x509/boring.go
+++ b/src/crypto/x509/boring.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto
+//go:build boringcrypto || goexperiment.opensslcrypto
 
 package x509
 
diff --git a/src/crypto/x509/boring_test.go b/src/crypto/x509/boring_test.go
index 7010f44b320..b61b90bdd95 100644
--- a/src/crypto/x509/boring_test.go
+++ b/src/crypto/x509/boring_test.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto
+//go:build boringcrypto || goexperiment.opensslcrypto
 
 package x509
 
diff --git a/src/crypto/x509/notboring.go b/src/crypto/x509/notboring.go
index c83a7272c9f..a0548a7f917 100644
--- a/src/crypto/x509/notboring.go
+++ b/src/crypto/x509/notboring.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build !boringcrypto
+//go:build !boringcrypto && !goexperiment.opensslcrypto
 
 package x509
 
diff --git a/src/runtime/mgc.go b/src/runtime/mgc.go
index 8b323c5bf79..056fdce6c32 100644
--- a/src/runtime/mgc.go
+++ b/src/runtime/mgc.go
@@ -1567,14 +1567,14 @@ func gcResetMarkState() {
 // Hooks for other packages
 
 var poolcleanup func()
-var boringCaches []unsafe.Pointer // for crypto/internal/boring
+var boringCaches []unsafe.Pointer // for crypto/internal/backend/bcache
 
 //go:linkname sync_runtime_registerPoolCleanup sync.runtime_registerPoolCleanup
 func sync_runtime_registerPoolCleanup(f func()) {
 	poolcleanup = f
 }
 
-//go:linkname boring_registerCache crypto/internal/boring.registerCache
+//go:linkname boring_registerCache crypto/internal/backend/bcache.registerCache
 func boring_registerCache(p unsafe.Pointer) {
 	boringCaches = append(boringCaches, p)
 }
