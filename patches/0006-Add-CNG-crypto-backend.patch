From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: qmuntal <qmuntaldiaz@microsoft.com>
Date: Tue, 19 Jul 2022 15:58:02 +0200
Subject: [PATCH] Add CNG crypto backend

---
 src/crypto/internal/backend/bbig/big_cng.go |  12 +
 src/crypto/internal/backend/cng_windows.go  | 329 ++++++++++++++++++++
 src/crypto/internal/backend/fips140/cng.go  |  33 ++
 3 files changed, 374 insertions(+)
 create mode 100644 src/crypto/internal/backend/bbig/big_cng.go
 create mode 100644 src/crypto/internal/backend/cng_windows.go
 create mode 100644 src/crypto/internal/backend/fips140/cng.go

diff --git a/src/crypto/internal/backend/bbig/big_cng.go b/src/crypto/internal/backend/bbig/big_cng.go
new file mode 100644
index 00000000000000..92623031fd87d0
--- /dev/null
+++ b/src/crypto/internal/backend/bbig/big_cng.go
@@ -0,0 +1,12 @@
+// Copyright 2022 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build goexperiment.cngcrypto
+
+package bbig
+
+import "github.com/microsoft/go-crypto-winnative/cng/bbig"
+
+var Enc = bbig.Enc
+var Dec = bbig.Dec
diff --git a/src/crypto/internal/backend/cng_windows.go b/src/crypto/internal/backend/cng_windows.go
new file mode 100644
index 00000000000000..6bfbdc57f0518b
--- /dev/null
+++ b/src/crypto/internal/backend/cng_windows.go
@@ -0,0 +1,329 @@
+// Copyright 2017 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build goexperiment.cngcrypto && windows
+
+// Package cng provides access to CNGCrypto implementation functions.
+// Check the variable Enabled to find out whether CNGCrypto is available.
+// If CNGCrypto is not available, the functions in this package all panic.
+package backend
+
+import (
+	"crypto"
+	"crypto/cipher"
+	"crypto/internal/backend/fips140"
+	"crypto/internal/boring/sig"
+	"hash"
+	_ "unsafe"
+
+	"github.com/microsoft/go-crypto-winnative/cng"
+)
+
+// Enabled controls whether FIPS crypto is enabled.
+const Enabled = true
+
+type BigInt = cng.BigInt
+
+func init() {
+	if fips140.Enabled() {
+		enabled, err := cng.FIPS()
+		if err != nil {
+			panic("cngcrypto: unknown FIPS mode: " + err.Error())
+		}
+		if !enabled {
+			panic("cngcrypto: not in FIPS mode")
+		}
+	}
+	sig.BoringCrypto()
+}
+
+const RandReader = cng.RandReader
+
+func SupportsHash(h crypto.Hash) bool {
+	return cng.SupportsHash(h)
+}
+
+func NewMD5() hash.Hash        { return cng.NewMD5() }
+func NewSHA1() hash.Hash       { return cng.NewSHA1() }
+func NewSHA224() hash.Hash     { panic("cngcrypto: not available") }
+func NewSHA256() hash.Hash     { return cng.NewSHA256() }
+func NewSHA384() hash.Hash     { return cng.NewSHA384() }
+func NewSHA512() hash.Hash     { return cng.NewSHA512() }
+func NewSHA512_224() hash.Hash { panic("cngcrypto: not available") }
+func NewSHA512_256() hash.Hash { panic("cngcrypto: not available") }
+
+func MD5(p []byte) (sum [16]byte)        { return cng.MD5(p) }
+func SHA1(p []byte) (sum [20]byte)       { return cng.SHA1(p) }
+func SHA224(p []byte) (sum [28]byte)     { panic("cngcrypto: not available") }
+func SHA256(p []byte) (sum [32]byte)     { return cng.SHA256(p) }
+func SHA384(p []byte) (sum [48]byte)     { return cng.SHA384(p) }
+func SHA512(p []byte) (sum [64]byte)     { return cng.SHA512(p) }
+func SHA512_224(p []byte) (sum [28]byte) { panic("cngcrypto: not available") }
+func SHA512_256(p []byte) (sum [32]byte) { panic("cngcrypto: not available") }
+
+func NewHMAC(h func() hash.Hash, key []byte) hash.Hash {
+	return cng.NewHMAC(h, key)
+}
+
+func NewAESCipher(key []byte) (cipher.Block, error) {
+	return cng.NewAESCipher(key)
+}
+
+func NewGCMTLS(c cipher.Block) (cipher.AEAD, error) {
+	return cng.NewGCMTLS(c)
+}
+
+func NewGCMTLS13(c cipher.Block) (cipher.AEAD, error) {
+	return cng.NewGCMTLS13(c)
+}
+
+type PublicKeyECDSA = cng.PublicKeyECDSA
+type PrivateKeyECDSA = cng.PrivateKeyECDSA
+
+func GenerateKeyECDSA(curve string) (X, Y, D cng.BigInt, err error) {
+	return cng.GenerateKeyECDSA(curve)
+}
+
+func NewPrivateKeyECDSA(curve string, X, Y, D cng.BigInt) (*cng.PrivateKeyECDSA, error) {
+	return cng.NewPrivateKeyECDSA(curve, X, Y, D)
+}
+
+func NewPublicKeyECDSA(curve string, X, Y cng.BigInt) (*cng.PublicKeyECDSA, error) {
+	return cng.NewPublicKeyECDSA(curve, X, Y)
+}
+
+//go:linkname encodeSignature crypto/ecdsa.encodeSignature
+func encodeSignature(r, s []byte) ([]byte, error)
+
+//go:linkname parseSignature crypto/ecdsa.parseSignature
+func parseSignature(sig []byte) (r, s []byte, err error)
+
+func SignMarshalECDSA(priv *cng.PrivateKeyECDSA, hash []byte) ([]byte, error) {
+	r, s, err := cng.SignECDSA(priv, hash)
+	if err != nil {
+		return nil, err
+	}
+	return encodeSignature(r, s)
+}
+
+func VerifyECDSA(pub *cng.PublicKeyECDSA, hash []byte, sig []byte) bool {
+	rBytes, sBytes, err := parseSignature(sig)
+	if err != nil {
+		return false
+	}
+	return cng.VerifyECDSA(pub, hash, cng.BigInt(rBytes), cng.BigInt(sBytes))
+}
+
+func SignECDSA(priv *cng.PrivateKeyECDSA, hash []byte) (r, s cng.BigInt, err error) {
+	return cng.SignECDSA(priv, hash)
+}
+
+func VerifyECDSARaw(pub *cng.PublicKeyECDSA, hash []byte, r, s cng.BigInt) bool {
+	return cng.VerifyECDSA(pub, hash, r, s)
+}
+
+func SupportsRSAKeyPrimes(primes int) bool {
+	// CNG only supports 2-prime RSA keys.
+	return primes == 2
+}
+
+func SupportsRSASaltLength(salt int) bool {
+	return salt != 0 // rsa.PSSSaltLengthAuto
+}
+
+type PublicKeyRSA = cng.PublicKeyRSA
+type PrivateKeyRSA = cng.PrivateKeyRSA
+
+func DecryptRSAOAEP(h, mgfHash hash.Hash, priv *cng.PrivateKeyRSA, ciphertext, label []byte) ([]byte, error) {
+	return cng.DecryptRSAOAEP(h, priv, ciphertext, label)
+}
+
+func DecryptRSAPKCS1(priv *cng.PrivateKeyRSA, ciphertext []byte) ([]byte, error) {
+	return cng.DecryptRSAPKCS1(priv, ciphertext)
+}
+
+func DecryptRSANoPadding(priv *cng.PrivateKeyRSA, ciphertext []byte) ([]byte, error) {
+	return cng.DecryptRSANoPadding(priv, ciphertext)
+}
+
+func EncryptRSAOAEP(h, mgfHash hash.Hash, pub *cng.PublicKeyRSA, msg, label []byte) ([]byte, error) {
+	return cng.EncryptRSAOAEP(h, pub, msg, label)
+}
+
+func EncryptRSAPKCS1(pub *cng.PublicKeyRSA, msg []byte) ([]byte, error) {
+	return cng.EncryptRSAPKCS1(pub, msg)
+}
+
+func EncryptRSANoPadding(pub *cng.PublicKeyRSA, msg []byte) ([]byte, error) {
+	return cng.EncryptRSANoPadding(pub, msg)
+}
+
+func GenerateKeyRSA(bits int) (N, E, D, P, Q, Dp, Dq, Qinv cng.BigInt, err error) {
+	return cng.GenerateKeyRSA(bits)
+}
+
+func NewPrivateKeyRSA(N, E, D, P, Q, Dp, Dq, Qinv cng.BigInt) (*cng.PrivateKeyRSA, error) {
+	return cng.NewPrivateKeyRSA(N, E, D, P, Q, Dp, Dq, Qinv)
+}
+
+func NewPublicKeyRSA(N, E cng.BigInt) (*cng.PublicKeyRSA, error) {
+	return cng.NewPublicKeyRSA(N, E)
+}
+
+func SignRSAPKCS1v15(priv *cng.PrivateKeyRSA, h crypto.Hash, hashed []byte) ([]byte, error) {
+	return cng.SignRSAPKCS1v15(priv, h, hashed)
+}
+
+func SignRSAPSS(priv *cng.PrivateKeyRSA, h crypto.Hash, hashed []byte, saltLen int) ([]byte, error) {
+	return cng.SignRSAPSS(priv, h, hashed, saltLen)
+}
+
+func VerifyRSAPKCS1v15(pub *cng.PublicKeyRSA, h crypto.Hash, hashed, sig []byte) error {
+	return cng.VerifyRSAPKCS1v15(pub, h, hashed, sig)
+}
+
+func VerifyRSAPSS(pub *cng.PublicKeyRSA, h crypto.Hash, hashed, sig []byte, saltLen int) error {
+	return cng.VerifyRSAPSS(pub, h, hashed, sig, saltLen)
+}
+
+type PrivateKeyECDH = cng.PrivateKeyECDH
+type PublicKeyECDH = cng.PublicKeyECDH
+
+func ECDH(priv *cng.PrivateKeyECDH, pub *cng.PublicKeyECDH) ([]byte, error) {
+	return cng.ECDH(priv, pub)
+}
+
+func GenerateKeyECDH(curve string) (*cng.PrivateKeyECDH, []byte, error) {
+	return cng.GenerateKeyECDH(curve)
+}
+
+func NewPrivateKeyECDH(curve string, bytes []byte) (*cng.PrivateKeyECDH, error) {
+	return cng.NewPrivateKeyECDH(curve, bytes)
+}
+
+func NewPublicKeyECDH(curve string, bytes []byte) (*cng.PublicKeyECDH, error) {
+	return cng.NewPublicKeyECDH(curve, bytes)
+}
+
+func SupportsHKDF() bool {
+	return cng.SupportsHKDF()
+}
+
+func ExpandHKDF(h func() hash.Hash, pseudorandomKey, info []byte, keyLength int) ([]byte, error) {
+	return cng.ExpandHKDF(h, pseudorandomKey, info, keyLength)
+}
+
+func ExtractHKDF(h func() hash.Hash, secret, salt []byte) ([]byte, error) {
+	return cng.ExtractHKDF(h, secret, salt)
+}
+
+func SupportsPBKDF2() bool { return true }
+
+func PBKDF2(password, salt []byte, iter, keyLen int, h func() hash.Hash) ([]byte, error) {
+	return cng.PBKDF2(password, salt, iter, keyLen, h)
+}
+
+func SupportsTLS1PRF() bool {
+	return true
+}
+
+func TLS1PRF(result, secret, label, seed []byte, h func() hash.Hash) error {
+	return cng.TLS1PRF(result, secret, label, seed, h)
+}
+
+func SupportsDESCipher() bool {
+	return true
+}
+
+func SupportsTripleDESCipher() bool {
+	return true
+}
+
+func NewDESCipher(key []byte) (cipher.Block, error) {
+	return cng.NewDESCipher(key)
+}
+
+func NewTripleDESCipher(key []byte) (cipher.Block, error) {
+	return cng.NewTripleDESCipher(key)
+}
+
+func SupportsRC4() bool { return true }
+
+type RC4Cipher = cng.RC4Cipher
+
+func NewRC4Cipher(key []byte) (*RC4Cipher, error) { return cng.NewRC4Cipher(key) }
+
+func SupportsEd25519() bool { return false }
+
+type PublicKeyEd25519 struct{}
+
+func (k *PublicKeyEd25519) Bytes() ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+
+type PrivateKeyEd25519 struct{}
+
+func (k *PrivateKeyEd25519) Bytes() ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+
+func GenerateKeyEd25519() (*PrivateKeyEd25519, error) {
+	panic("cryptobackend: not available")
+}
+
+func NewPrivateKeyEd25519(priv []byte) (*PrivateKeyEd25519, error) {
+	panic("cryptobackend: not available")
+}
+
+func NewPublicKeyEd25519(pub []byte) (*PublicKeyEd25519, error) {
+	panic("cryptobackend: not available")
+}
+
+func NewPrivateKeyEd25519FromSeed(seed []byte) (*PrivateKeyEd25519, error) {
+	panic("cryptobackend: not available")
+}
+
+func SignEd25519(priv *PrivateKeyEd25519, message []byte) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+
+func VerifyEd25519(pub *PublicKeyEd25519, message, sig []byte) error {
+	panic("cryptobackend: not available")
+}
+
+type PrivateKeyDSA = cng.PrivateKeyDSA
+type PublicKeyDSA = cng.PublicKeyDSA
+
+func SupportsDSA(l, n int) bool {
+	// These are the only N values supported by CNG
+	return n == 160 || n == 256
+}
+
+func GenerateParametersDSA(l, n int) (p, q, g cng.BigInt, err error) {
+	params, err := cng.GenerateParametersDSA(l)
+	if err != nil {
+		return nil, nil, nil, err
+	}
+	return params.P, params.Q, params.G, nil
+}
+
+func GenerateKeyDSA(p, q, g cng.BigInt) (x, y cng.BigInt, err error) {
+	return cng.GenerateKeyDSA(cng.DSAParameters{P: p, Q: q, G: g})
+}
+
+func NewPrivateKeyDSA(p, q, g, x, y cng.BigInt) (*cng.PrivateKeyDSA, error) {
+	return cng.NewPrivateKeyDSA(cng.DSAParameters{P: p, Q: q, G: g}, x, y)
+}
+
+func NewPublicKeyDSA(p, q, g, y cng.BigInt) (*cng.PublicKeyDSA, error) {
+	return cng.NewPublicKeyDSA(cng.DSAParameters{P: p, Q: q, G: g}, y)
+}
+
+func SignDSA(priv *PrivateKeyDSA, hash []byte, parseSignature func([]byte) (cng.BigInt, cng.BigInt, error)) (r, s cng.BigInt, err error) {
+	return cng.SignDSA(priv, hash)
+}
+
+func VerifyDSA(pub *PublicKeyDSA, hashed []byte, r, s cng.BigInt, encodeSignature func(r, s cng.BigInt) ([]byte, error)) bool {
+	return cng.VerifyDSA(pub, hashed, r, s)
+}
diff --git a/src/crypto/internal/backend/fips140/cng.go b/src/crypto/internal/backend/fips140/cng.go
new file mode 100644
index 00000000000000..f769d15f94ab05
--- /dev/null
+++ b/src/crypto/internal/backend/fips140/cng.go
@@ -0,0 +1,33 @@
+// Copyright 2024 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build goexperiment.cngcrypto
+
+package fips140
+
+import (
+	"internal/syscall/windows/sysdll"
+	"syscall"
+	"unsafe"
+)
+
+// Don't use github.com/microsoft/go-crypto-winnative here.
+// The fips140 package should have minimal dependencies.
+// Also, don't directly query the system FIPS mode from the registry,
+// there are some no-longer documented legacy entries that can enable FIPS mode,
+// and BCryptGetFipsAlgorithmMode supports them all.
+var (
+	bcrypt = syscall.MustLoadDLL(sysdll.Add("bcrypt.dll"))
+
+	bcryptGetFipsAlgorithmMode = bcrypt.MustFindProc("BCryptGetFipsAlgorithmMode")
+)
+
+func systemFIPSMode() bool {
+	var enabled uint32
+	ret, _, _ := bcryptGetFipsAlgorithmMode.Call(uintptr(unsafe.Pointer(&enabled)))
+	if ret != 0 {
+		return false
+	}
+	return enabled != 0
+}
