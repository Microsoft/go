From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: qmuntal <qmuntaldiaz@microsoft.com>
Date: Tue, 14 Jan 2025 11:09:56 +0100
Subject: [PATCH] Add crypto backend foundation

---
 src/crypto/internal/backend/backend_test.go   |  30 +++
 src/crypto/internal/backend/bbig/big.go       |  17 ++
 src/crypto/internal/backend/common.go         |  58 +++++
 .../internal/backend/fips140/fips140.go       |  55 ++++
 .../internal/backend/fips140/isrequirefips.go |   9 +
 .../internal/backend/fips140/norequirefips.go |   9 +
 .../backend/fips140/nosystemcrypto.go         |  11 +
 src/crypto/internal/backend/nobackend.go      | 236 ++++++++++++++++++
 src/crypto/internal/backend/stub.s            |  10 +
 src/go/build/deps_test.go                     |   7 +-
 src/runtime/runtime_boring.go                 |   5 +
 11 files changed, 446 insertions(+), 1 deletion(-)
 create mode 100644 src/crypto/internal/backend/backend_test.go
 create mode 100644 src/crypto/internal/backend/bbig/big.go
 create mode 100644 src/crypto/internal/backend/common.go
 create mode 100644 src/crypto/internal/backend/fips140/fips140.go
 create mode 100644 src/crypto/internal/backend/fips140/isrequirefips.go
 create mode 100644 src/crypto/internal/backend/fips140/norequirefips.go
 create mode 100644 src/crypto/internal/backend/fips140/nosystemcrypto.go
 create mode 100644 src/crypto/internal/backend/nobackend.go
 create mode 100644 src/crypto/internal/backend/stub.s

diff --git a/src/crypto/internal/backend/backend_test.go b/src/crypto/internal/backend/backend_test.go
new file mode 100644
index 00000000000000..c2c06d3bff8c74
--- /dev/null
+++ b/src/crypto/internal/backend/backend_test.go
@@ -0,0 +1,30 @@
+// Copyright 2017 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package backend
+
+import (
+	"testing"
+)
+
+// Test that Unreachable panics.
+func TestUnreachable(t *testing.T) {
+	defer func() {
+		if Enabled {
+			if err := recover(); err == nil {
+				t.Fatal("expected Unreachable to panic")
+			}
+		} else {
+			if err := recover(); err != nil {
+				t.Fatalf("expected Unreachable to be a no-op")
+			}
+		}
+	}()
+	Unreachable()
+}
+
+// Test that UnreachableExceptTests does not panic (this is a test).
+func TestUnreachableExceptTests(t *testing.T) {
+	UnreachableExceptTests()
+}
diff --git a/src/crypto/internal/backend/bbig/big.go b/src/crypto/internal/backend/bbig/big.go
new file mode 100644
index 00000000000000..ab3f30825dcfa1
--- /dev/null
+++ b/src/crypto/internal/backend/bbig/big.go
@@ -0,0 +1,17 @@
+// Copyright 2022 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build !goexperiment.systemcrypto || (goexperiment.darwincrypto && !cgo)
+
+package bbig
+
+import "math/big"
+
+func Enc(b *big.Int) []uint {
+	return nil
+}
+
+func Dec(b []uint) *big.Int {
+	return nil
+}
diff --git a/src/crypto/internal/backend/common.go b/src/crypto/internal/backend/common.go
new file mode 100644
index 00000000000000..84447174284ffd
--- /dev/null
+++ b/src/crypto/internal/backend/common.go
@@ -0,0 +1,58 @@
+// Copyright 2022 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package backend
+
+import (
+	"crypto/internal/backend/fips140"
+	"crypto/internal/boring/sig"
+	"runtime"
+)
+
+func init() {
+	if fips140.Enabled() {
+		if !Enabled {
+			if runtime.GOOS != "linux" && runtime.GOOS != "windows" && runtime.GOOS != "darwin" {
+				panic("FIPS mode requested (" + fips140.Message + ") but no crypto backend is supported on " + runtime.GOOS)
+			}
+			panic("FIPS mode requested (" + fips140.Message + ") but no supported crypto backend is enabled")
+		}
+	}
+}
+
+// Unreachable marks code that should be unreachable
+// when backend is in use.
+func Unreachable() {
+	if Enabled {
+		panic("cryptobackend: invalid code execution")
+	} else {
+		// Code that's unreachable is exactly the code
+		// we want to detect for reporting standard Go crypto.
+		sig.StandardCrypto()
+	}
+}
+
+// Provided by runtime.crypto_backend_runtime_arg0 to avoid os import.
+func runtime_arg0() string
+
+func hasSuffix(s, t string) bool {
+	return len(s) > len(t) && s[len(s)-len(t):] == t
+}
+
+// UnreachableExceptTests marks code that should be unreachable
+// when backend is in use. It panics.
+func UnreachableExceptTests() {
+	// runtime_arg0 is not supported on windows.
+	// We are going through the same code patch on linux,
+	// so if we are unintentionally calling an 'unreachable' function,
+	// we will catch it there.
+	if Enabled && runtime.GOOS != "windows" {
+		name := runtime_arg0()
+		// If ran on Windows we'd need to allow _test.exe and .test.exe as well.
+		if !hasSuffix(name, "_test") && !hasSuffix(name, ".test") {
+			println("cryptobackend: unexpected code execution in", name)
+			panic("cryptobackend: invalid code execution")
+		}
+	}
+}
diff --git a/src/crypto/internal/backend/fips140/fips140.go b/src/crypto/internal/backend/fips140/fips140.go
new file mode 100644
index 00000000000000..f54d39970319af
--- /dev/null
+++ b/src/crypto/internal/backend/fips140/fips140.go
@@ -0,0 +1,55 @@
+// Copyright 2024 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package fips140
+
+import "syscall"
+
+// Enabled reports whether FIPS 140 mode is enabled by using GOFIPS=1, GOLANG_FIPS=1,
+// the 'requirefips' build tag, or any other platform-specific mechanism.
+func Enabled() bool {
+	return enabled
+}
+
+var enabled bool
+
+// Disabled reports whether FIPS 140 mode is disabled by using GOFIPS=0 or GOLANG_FIPS=0.
+func Disabled() bool {
+	return disabled
+}
+
+var disabled bool
+
+// Message is a human-readable message about how [Enabled] was set.
+var Message string
+
+func init() {
+	// TODO: Decide which environment variable to use.
+	// See https://github.com/microsoft/go/issues/397.
+	var value string
+	var ok bool
+	if value, ok = syscall.Getenv("GOFIPS"); ok {
+		Message = "environment variable GOFIPS"
+	} else if value, ok = syscall.Getenv("GOLANG_FIPS"); ok {
+		Message = "environment variable GOLANG_FIPS"
+	} else if systemFIPSMode() {
+		Message = "system FIPS mode"
+		value = "1"
+	}
+	if value == "1" {
+		enabled = true
+	} else if value == "0" {
+		disabled = true
+	}
+	if isRequireFIPS {
+		if disabled {
+			panic("the 'requirefips' build tag is enabled, but it conflicts " +
+				"with the " + Message + "=" + value +
+				" which would disable FIPS mode")
+		}
+		Message = "requirefips tag set"
+		enabled = true
+		return
+	}
+}
\ No newline at end of file
diff --git a/src/crypto/internal/backend/fips140/isrequirefips.go b/src/crypto/internal/backend/fips140/isrequirefips.go
new file mode 100644
index 00000000000000..b33d08c84e2dae
--- /dev/null
+++ b/src/crypto/internal/backend/fips140/isrequirefips.go
@@ -0,0 +1,9 @@
+// Copyright 2024 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build requirefips
+
+package fips140
+
+const isRequireFIPS = true
\ No newline at end of file
diff --git a/src/crypto/internal/backend/fips140/norequirefips.go b/src/crypto/internal/backend/fips140/norequirefips.go
new file mode 100644
index 00000000000000..6f01b9a3524dee
--- /dev/null
+++ b/src/crypto/internal/backend/fips140/norequirefips.go
@@ -0,0 +1,9 @@
+// Copyright 2024 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build !requirefips
+
+package fips140
+
+const isRequireFIPS = false
\ No newline at end of file
diff --git a/src/crypto/internal/backend/fips140/nosystemcrypto.go b/src/crypto/internal/backend/fips140/nosystemcrypto.go
new file mode 100644
index 00000000000000..83691d7dd42d51
--- /dev/null
+++ b/src/crypto/internal/backend/fips140/nosystemcrypto.go
@@ -0,0 +1,11 @@
+// Copyright 2024 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build !goexperiment.systemcrypto
+
+package fips140
+
+func systemFIPSMode() bool {
+	return false
+}
diff --git a/src/crypto/internal/backend/nobackend.go b/src/crypto/internal/backend/nobackend.go
new file mode 100644
index 00000000000000..6172004c0b19e4
--- /dev/null
+++ b/src/crypto/internal/backend/nobackend.go
@@ -0,0 +1,236 @@
+// Copyright 2017 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Do not edit the build constraint by hand. It is generated by "backendgen.go".
+
+//go:build ignore
+
+package backend
+
+import (
+	"crypto"
+	"crypto/cipher"
+	"hash"
+)
+
+const Enabled = false
+
+type BigInt = []uint
+
+type randReader int
+
+func (randReader) Read(b []byte) (int, error) { panic("cryptobackend: not available") }
+
+const RandReader = randReader(0)
+
+func SupportsHash(h crypto.Hash) bool { panic("cryptobackend: not available") }
+
+func NewMD5() hash.Hash        { panic("cryptobackend: not available") }
+func NewSHA1() hash.Hash       { panic("cryptobackend: not available") }
+func NewSHA224() hash.Hash     { panic("cryptobackend: not available") }
+func NewSHA256() hash.Hash     { panic("cryptobackend: not available") }
+func NewSHA384() hash.Hash     { panic("cryptobackend: not available") }
+func NewSHA512() hash.Hash     { panic("cryptobackend: not available") }
+func NewSHA512_224() hash.Hash { panic("cryptobackend: not available") }
+func NewSHA512_256() hash.Hash { panic("cryptobackend: not available") }
+
+func MD5(p []byte) (sum [16]byte)        { panic("cryptobackend: not available") }
+func SHA1(p []byte) (sum [20]byte)       { panic("cryptobackend: not available") }
+func SHA224(p []byte) (sum [28]byte)     { panic("cryptobackend: not available") }
+func SHA256(p []byte) (sum [32]byte)     { panic("cryptobackend: not available") }
+func SHA384(p []byte) (sum [48]byte)     { panic("cryptobackend: not available") }
+func SHA512(p []byte) (sum [64]byte)     { panic("cryptobackend: not available") }
+func SHA512_224(p []byte) (sum [28]byte) { panic("cryptobackend: not available") }
+func SHA512_256(p []byte) (sum [32]byte) { panic("cryptobackend: not available") }
+
+func NewHMAC(h func() hash.Hash, key []byte) hash.Hash { panic("cryptobackend: not available") }
+
+func NewAESCipher(key []byte) (cipher.Block, error)   { panic("cryptobackend: not available") }
+func NewGCMTLS(c cipher.Block) (cipher.AEAD, error)   { panic("cryptobackend: not available") }
+func NewGCMTLS13(c cipher.Block) (cipher.AEAD, error) { panic("cryptobackend: not available") }
+
+type PublicKeyECDSA struct{ _ int }
+type PrivateKeyECDSA struct{ _ int }
+
+func GenerateKeyECDSA(curve string) (X, Y, D BigInt, err error) {
+	panic("cryptobackend: not available")
+}
+func NewPrivateKeyECDSA(curve string, X, Y, D BigInt) (*PrivateKeyECDSA, error) {
+	panic("cryptobackend: not available")
+}
+func NewPublicKeyECDSA(curve string, X, Y BigInt) (*PublicKeyECDSA, error) {
+	panic("cryptobackend: not available")
+}
+func SignMarshalECDSA(priv *PrivateKeyECDSA, hash []byte) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+func VerifyECDSA(pub *PublicKeyECDSA, hash []byte, sig []byte) bool {
+	panic("cryptobackend: not available")
+}
+
+func SupportsRSAKeyPrimes(primes int) bool           { panic("cryptobackend: not available") }
+func SupportsRSASaltLength(sign bool, salt int) bool { panic("cryptobackend: not available") }
+
+type PublicKeyRSA struct{ _ int }
+type PrivateKeyRSA struct{ _ int }
+
+func DecryptRSAOAEP(h, mgfHash hash.Hash, priv *PrivateKeyRSA, ciphertext, label []byte) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+func DecryptRSAPKCS1(priv *PrivateKeyRSA, ciphertext []byte) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+func DecryptRSANoPadding(priv *PrivateKeyRSA, ciphertext []byte) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+func EncryptRSAOAEP(h, mgfHash hash.Hash, pub *PublicKeyRSA, msg, label []byte) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+func EncryptRSAPKCS1(pub *PublicKeyRSA, msg []byte) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+func EncryptRSANoPadding(pub *PublicKeyRSA, msg []byte) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+func GenerateKeyRSA(bits int) (N, E, D, P, Q, Dp, Dq, Qinv BigInt, err error) {
+	panic("cryptobackend: not available")
+}
+func NewPrivateKeyRSA(N, E, D, P, Q, Dp, Dq, Qinv BigInt) (*PrivateKeyRSA, error) {
+	panic("cryptobackend: not available")
+}
+func NewPublicKeyRSA(N, E BigInt) (*PublicKeyRSA, error) {
+	panic("cryptobackend: not available")
+}
+func SignRSAPKCS1v15(priv *PrivateKeyRSA, h crypto.Hash, hashed []byte) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+func SignRSAPSS(priv *PrivateKeyRSA, h crypto.Hash, hashed []byte, saltLen int) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+func VerifyRSAPKCS1v15(pub *PublicKeyRSA, h crypto.Hash, hashed, sig []byte) error {
+	panic("cryptobackend: not available")
+}
+func VerifyRSAPSS(pub *PublicKeyRSA, h crypto.Hash, hashed, sig []byte, saltLen int) error {
+	panic("cryptobackend: not available")
+}
+
+type PublicKeyECDH struct{}
+type PrivateKeyECDH struct{}
+
+func ECDH(*PrivateKeyECDH, *PublicKeyECDH) ([]byte, error)    { panic("cryptobackend: not available") }
+func GenerateKeyECDH(string) (*PrivateKeyECDH, []byte, error) { panic("cryptobackend: not available") }
+func NewPrivateKeyECDH(string, []byte) (*PrivateKeyECDH, error) {
+	panic("cryptobackend: not available")
+}
+func NewPublicKeyECDH(string, []byte) (*PublicKeyECDH, error) { panic("cryptobackend: not available") }
+func (*PublicKeyECDH) Bytes() []byte                          { panic("cryptobackend: not available") }
+func (*PrivateKeyECDH) PublicKey() (*PublicKeyECDH, error)    { panic("cryptobackend: not available") }
+
+func SupportsHKDF() bool { panic("cryptobackend: not available") }
+
+func ExpandHKDF(h func() hash.Hash, pseudorandomKey, info []byte, keyLength int) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+
+func ExtractHKDF(h func() hash.Hash, secret, salt []byte) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+
+func SupportsPBKDF2() bool { panic("cryptobackend: not available") }
+
+func PBKDF2(password, salt []byte, iter, keyLen int, fh func() hash.Hash) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+
+func SupportsTLS1PRF() bool { panic("cryptobackend: not available") }
+
+func TLS1PRF(result, secret, label, seed []byte, h func() hash.Hash) error {
+	panic("cryptobackend: not available")
+}
+
+func SupportsDESCipher() bool { panic("cryptobackend: not available") }
+
+func SupportsTripleDESCipher() bool { panic("cryptobackend: not available") }
+
+func NewDESCipher(key []byte) (cipher.Block, error) { panic("cryptobackend: not available") }
+
+func NewTripleDESCipher(key []byte) (cipher.Block, error) { panic("cryptobackend: not available") }
+
+func SupportsRC4() bool { panic("cryptobackend: not available") }
+
+type RC4Cipher struct{}
+
+func (c *RC4Cipher) Reset()                       { panic("cryptobackend: not available") }
+func (c *RC4Cipher) XORKeyStream(dst, src []byte) { panic("cryptobackend: not available") }
+
+func NewRC4Cipher(key []byte) (*RC4Cipher, error) { panic("cryptobackend: not available") }
+
+func SupportsEd25519() bool { panic("cryptobackend: not available") }
+
+type PublicKeyEd25519 struct{}
+
+func (k PublicKeyEd25519) Bytes() ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+
+type PrivateKeyEd25519 struct{}
+
+func (k PrivateKeyEd25519) Bytes() ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+
+func GenerateKeyEd25519() (PrivateKeyEd25519, error) {
+	panic("cryptobackend: not available")
+}
+
+func NewPrivateKeyEd25519(priv []byte) (PrivateKeyEd25519, error) {
+	panic("cryptobackend: not available")
+}
+
+func NewPublicKeyEd25519(pub []byte) (PublicKeyEd25519, error) {
+	panic("cryptobackend: not available")
+}
+
+func NewPrivateKeyEd25519FromSeed(seed []byte) (PrivateKeyEd25519, error) {
+	panic("cryptobackend: not available")
+}
+
+func SignEd25519(priv PrivateKeyEd25519, message []byte) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+
+func VerifyEd25519(pub PublicKeyEd25519, message, sig []byte) error {
+	panic("cryptobackend: not available")
+}
+
+func SupportsDSA(l, n int) bool {
+	panic("cryptobackend: not available")
+}
+
+func GenerateParametersDSA(l, n int) (p, q, g BigInt, err error) {
+	panic("cryptobackend: not available")
+}
+
+type PublicKeyDSA struct{ _ int }
+type PrivateKeyDSA struct{ _ int }
+
+func GenerateKeyDSA(p, q, g BigInt) (x, y BigInt, err error) {
+	panic("cryptobackend: not available")
+}
+
+func NewPrivateKeyDSA(p, q, g, x, y BigInt) (*PrivateKeyDSA, error) {
+	panic("cryptobackend: not available")
+}
+
+func NewPublicKeyDSA(p, q, g, y BigInt) (*PublicKeyDSA, error) {
+	panic("cryptobackend: not available")
+}
+
+func SignDSA(priv *PrivateKeyDSA, hash []byte, parseSignature func([]byte) (BigInt, BigInt, error)) (r, s BigInt, err error) {
+	panic("cryptobackend: not available")
+}
+
+func VerifyDSA(pub *PublicKeyDSA, hashed []byte, r, s BigInt, encodeSignature func(r, s BigInt) ([]byte, error)) bool {
+	panic("cryptobackend: not available")
+}
diff --git a/src/crypto/internal/backend/stub.s b/src/crypto/internal/backend/stub.s
new file mode 100644
index 00000000000000..5e4b436554d44d
--- /dev/null
+++ b/src/crypto/internal/backend/stub.s
@@ -0,0 +1,10 @@
+// Copyright 2017 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// runtime_arg0 is declared in common.go without a body.
+// It's provided by package runtime,
+// but the go command doesn't know that.
+// Having this assembly file keeps the go command
+// from complaining about the missing body
+// (because the implementation might be here).
diff --git a/src/go/build/deps_test.go b/src/go/build/deps_test.go
index e017efb1562379..ab5539f978a266 100644
--- a/src/go/build/deps_test.go
+++ b/src/go/build/deps_test.go
@@ -493,6 +493,8 @@ var depsRules = `
 	< crypto/internal/fips140/rsa
 	< FIPS;
 
+	syscall < crypto/internal/backend/fips140;
+
 	FIPS, internal/godebug < crypto/fips140;
 
 	crypto, hash !< FIPS;
@@ -506,7 +508,8 @@ var depsRules = `
 	FIPS, internal/godebug, hash, embed, encoding/binary,
 	crypto/internal/boring/sig,
 	crypto/internal/boring/syso,
-	crypto/internal/boring/bcache
+	crypto/internal/boring/bcache,
+	crypto/internal/backend/fips140
 	< crypto/internal/fips140only
 	< crypto
 	< crypto/subtle
@@ -522,6 +525,7 @@ var depsRules = `
 	< github.com/microsoft/go-crypto-winnative/internal/bcrypt
 	< github.com/microsoft/go-crypto-winnative/cng
 	< crypto/internal/boring
+	< crypto/internal/backend
 	< crypto/boring
 	< crypto/aes,
 	  crypto/des,
@@ -546,6 +550,7 @@ var depsRules = `
 	< github.com/microsoft/go-crypto-darwin/bbig
 	< github.com/microsoft/go-crypto-winnative/cng/bbig
 	< crypto/internal/boring/bbig
+	< crypto/internal/backend/bbig
 	< crypto/rand
 	< crypto/ed25519 # depends on crypto/rand.Reader
 	< encoding/asn1
diff --git a/src/runtime/runtime_boring.go b/src/runtime/runtime_boring.go
index 5a98b20253181c..9042f2c2795e19 100644
--- a/src/runtime/runtime_boring.go
+++ b/src/runtime/runtime_boring.go
@@ -17,3 +17,8 @@ func boring_runtime_arg0() string {
 
 //go:linkname fipstls_runtime_arg0 crypto/internal/boring/fipstls.runtime_arg0
 func fipstls_runtime_arg0() string { return boring_runtime_arg0() }
+
+//go:linkname crypto_backend_runtime_arg0 crypto/internal/backend.runtime_arg0
+func crypto_backend_runtime_arg0() string {
+	return boring_runtime_arg0()
+}
