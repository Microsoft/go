From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Quim Muntal <qmuntaldiaz@microsoft.com>
Date: Mon, 23 May 2022 12:51:56 +0000
Subject: [PATCH] Add OpenSSL crypto module

---
 src/crypto/internal/backend/backend_test.go   |  30 ++++
 src/crypto/internal/backend/bbig/big.go       |  20 +++
 .../internal/backend/bbig/big_boring.go       |  12 ++
 .../internal/backend/bbig/big_openssl.go      |  12 ++
 src/crypto/internal/backend/bcache/cache.go   | 140 +++++++++++++++++
 .../internal/backend/bcache/cache_test.go     | 120 +++++++++++++++
 src/crypto/internal/backend/bcache/stub.s     |  10 ++
 src/crypto/internal/backend/common.go         |  34 ++++
 src/crypto/internal/backend/iscgo.go          |  10 ++
 src/crypto/internal/backend/nobackend.go      | 115 ++++++++++++++
 src/crypto/internal/backend/nocgo.go          |  10 ++
 src/crypto/internal/backend/openssl_linux.go  | 145 ++++++++++++++++++
 src/crypto/internal/backend/stub.s            |  10 ++
 src/go.mod                                    |   1 +
 src/go.sum                                    |   2 +
 src/runtime/runtime_boring.go                 |   5 +
 16 files changed, 676 insertions(+)
 create mode 100644 src/crypto/internal/backend/backend_test.go
 create mode 100644 src/crypto/internal/backend/bbig/big.go
 create mode 100644 src/crypto/internal/backend/bbig/big_boring.go
 create mode 100644 src/crypto/internal/backend/bbig/big_openssl.go
 create mode 100644 src/crypto/internal/backend/bcache/cache.go
 create mode 100644 src/crypto/internal/backend/bcache/cache_test.go
 create mode 100644 src/crypto/internal/backend/bcache/stub.s
 create mode 100644 src/crypto/internal/backend/common.go
 create mode 100644 src/crypto/internal/backend/iscgo.go
 create mode 100644 src/crypto/internal/backend/nobackend.go
 create mode 100644 src/crypto/internal/backend/nocgo.go
 create mode 100644 src/crypto/internal/backend/openssl_linux.go
 create mode 100644 src/crypto/internal/backend/stub.s

diff --git a/src/crypto/internal/backend/backend_test.go b/src/crypto/internal/backend/backend_test.go
new file mode 100644
index 00000000000..c2c06d3bff8
--- /dev/null
+++ b/src/crypto/internal/backend/backend_test.go
@@ -0,0 +1,30 @@
+// Copyright 2017 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package backend
+
+import (
+	"testing"
+)
+
+// Test that Unreachable panics.
+func TestUnreachable(t *testing.T) {
+	defer func() {
+		if Enabled {
+			if err := recover(); err == nil {
+				t.Fatal("expected Unreachable to panic")
+			}
+		} else {
+			if err := recover(); err != nil {
+				t.Fatalf("expected Unreachable to be a no-op")
+			}
+		}
+	}()
+	Unreachable()
+}
+
+// Test that UnreachableExceptTests does not panic (this is a test).
+func TestUnreachableExceptTests(t *testing.T) {
+	UnreachableExceptTests()
+}
diff --git a/src/crypto/internal/backend/bbig/big.go b/src/crypto/internal/backend/bbig/big.go
new file mode 100644
index 00000000000..de03a25e114
--- /dev/null
+++ b/src/crypto/internal/backend/bbig/big.go
@@ -0,0 +1,20 @@
+// Copyright 2022 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build !boringcrypto && !goexperiment.opensslcrypto
+
+package bbig
+
+import (
+	"crypto/internal/backend"
+	"math/big"
+)
+
+func Enc(b *big.Int) backend.BigInt {
+	return nil
+}
+
+func Dec(b backend.BigInt) *big.Int {
+	return nil
+}
diff --git a/src/crypto/internal/backend/bbig/big_boring.go b/src/crypto/internal/backend/bbig/big_boring.go
new file mode 100644
index 00000000000..0b62cef6854
--- /dev/null
+++ b/src/crypto/internal/backend/bbig/big_boring.go
@@ -0,0 +1,12 @@
+// Copyright 2022 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build goexperiment.boringcrypto
+
+package bbig
+
+import "crypto/internal/boring/bbig"
+
+var Enc = bbig.Enc
+var Dec = bbig.Dec
diff --git a/src/crypto/internal/backend/bbig/big_openssl.go b/src/crypto/internal/backend/bbig/big_openssl.go
new file mode 100644
index 00000000000..61ef3fdd90b
--- /dev/null
+++ b/src/crypto/internal/backend/bbig/big_openssl.go
@@ -0,0 +1,12 @@
+// Copyright 2022 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build goexperiment.opensslcrypto
+
+package bbig
+
+import "github.com/microsoft/go-crypto-openssl/openssl/bbig"
+
+var Enc = bbig.Enc
+var Dec = bbig.Dec
diff --git a/src/crypto/internal/backend/bcache/cache.go b/src/crypto/internal/backend/bcache/cache.go
new file mode 100644
index 00000000000..6d6d7982a09
--- /dev/null
+++ b/src/crypto/internal/backend/bcache/cache.go
@@ -0,0 +1,140 @@
+// Copyright 2022 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package bcache
+
+import (
+	"sync/atomic"
+	"unsafe"
+)
+
+// A Cache is a GC-friendly concurrent map from unsafe.Pointer to
+// unsafe.Pointer. It is meant to be used for maintaining shadow
+// BoringCrypto state associated with certain allocated structs, in
+// particular public and private RSA and ECDSA keys.
+//
+// The cache is GC-friendly in the sense that the keys do not
+// indefinitely prevent the garbage collector from collecting them.
+// Instead, at the start of each GC, the cache is cleared entirely. That
+// is, the cache is lossy, and the loss happens at the start of each GC.
+// This means that clients need to be able to cope with cache entries
+// disappearing, but it also means that clients don't need to worry about
+// cache entries keeping the keys from being collected.
+//
+// TODO(rsc): Make Cache generic once consumers can handle that.
+type Cache struct {
+	// ptable is an atomic *[cacheSize]unsafe.Pointer,
+	// where each unsafe.Pointer is an atomic *cacheEntry.
+	// The runtime atomically stores nil to ptable at the start of each GC.
+	ptable unsafe.Pointer
+}
+
+// A cacheEntry is a single entry in the linked list for a given hash table entry.
+type cacheEntry struct {
+	k    unsafe.Pointer // immutable once created
+	v    unsafe.Pointer // read and written atomically to allow updates
+	next *cacheEntry    // immutable once linked into table
+}
+
+func registerCache(unsafe.Pointer) // provided by runtime
+
+// Register registers the cache with the runtime,
+// so that c.ptable can be cleared at the start of each GC.
+// Register must be called during package initialization.
+func (c *Cache) Register() {
+	registerCache(unsafe.Pointer(&c.ptable))
+}
+
+// cacheSize is the number of entries in the hash table.
+// The hash is the pointer value mod cacheSize, a prime.
+// Collisions are resolved by maintaining a linked list in each hash slot.
+const cacheSize = 1021
+
+// table returns a pointer to the current cache hash table,
+// coping with the possibility of the GC clearing it out from under us.
+func (c *Cache) table() *[cacheSize]unsafe.Pointer {
+	for {
+		p := atomic.LoadPointer(&c.ptable)
+		if p == nil {
+			p = unsafe.Pointer(new([cacheSize]unsafe.Pointer))
+			if !atomic.CompareAndSwapPointer(&c.ptable, nil, p) {
+				continue
+			}
+		}
+		return (*[cacheSize]unsafe.Pointer)(p)
+	}
+}
+
+// Clear clears the cache.
+// The runtime does this automatically at each garbage collection;
+// this method is exposed only for testing.
+func (c *Cache) Clear() {
+	// The runtime does this at the start of every garbage collection
+	// (itself, not by calling this function).
+	atomic.StorePointer(&c.ptable, nil)
+}
+
+// Get returns the cached value associated with v,
+// which is either the value v corresponding to the most recent call to Put(k, v)
+// or nil if that cache entry has been dropped.
+func (c *Cache) Get(k unsafe.Pointer) unsafe.Pointer {
+	head := &c.table()[uintptr(k)%cacheSize]
+	e := (*cacheEntry)(atomic.LoadPointer(head))
+	for ; e != nil; e = e.next {
+		if e.k == k {
+			return atomic.LoadPointer(&e.v)
+		}
+	}
+	return nil
+}
+
+// Put sets the cached value associated with k to v.
+func (c *Cache) Put(k, v unsafe.Pointer) {
+	head := &c.table()[uintptr(k)%cacheSize]
+
+	// Strategy is to walk the linked list at head,
+	// same as in Get, to look for existing entry.
+	// If we find one, we update v atomically in place.
+	// If not, then we race to replace the start = *head
+	// we observed with a new k, v entry.
+	// If we win that race, we're done.
+	// Otherwise, we try the whole thing again,
+	// with two optimizations:
+	//
+	//  1. We track in noK the start of the section of
+	//     the list that we've confirmed has no entry for k.
+	//     The next time down the list, we can stop at noK,
+	//     because new entries are inserted at the front of the list.
+	//     This guarantees we never traverse an entry
+	//     multiple times.
+	//
+	//  2. We only allocate the entry to be added once,
+	//     saving it in add for the next attempt.
+	var add, noK *cacheEntry
+	n := 0
+	for {
+		e := (*cacheEntry)(atomic.LoadPointer(head))
+		start := e
+		for ; e != nil && e != noK; e = e.next {
+			if e.k == k {
+				atomic.StorePointer(&e.v, v)
+				return
+			}
+			n++
+		}
+		if add == nil {
+			add = &cacheEntry{k, v, nil}
+		}
+		add.next = start
+		if n >= 1000 {
+			// If an individual list gets too long, which shouldn't happen,
+			// throw it away to avoid quadratic lookup behavior.
+			add.next = nil
+		}
+		if atomic.CompareAndSwapPointer(head, unsafe.Pointer(start), unsafe.Pointer(add)) {
+			return
+		}
+		noK = start
+	}
+}
diff --git a/src/crypto/internal/backend/bcache/cache_test.go b/src/crypto/internal/backend/bcache/cache_test.go
new file mode 100644
index 00000000000..8b2cf3d0941
--- /dev/null
+++ b/src/crypto/internal/backend/bcache/cache_test.go
@@ -0,0 +1,120 @@
+// Copyright 2022 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package bcache
+
+import (
+	"fmt"
+	"runtime"
+	"sync"
+	"sync/atomic"
+	"testing"
+	"unsafe"
+)
+
+var registeredCache Cache
+
+func init() {
+	registeredCache.Register()
+}
+
+func TestCache(t *testing.T) {
+	// Use unregistered cache for functionality tests,
+	// to keep the runtime from clearing behind our backs.
+	c := new(Cache)
+
+	// Create many entries.
+	seq := uint32(0)
+	next := func() unsafe.Pointer {
+		x := new(int)
+		*x = int(atomic.AddUint32(&seq, 1))
+		return unsafe.Pointer(x)
+	}
+	m := make(map[unsafe.Pointer]unsafe.Pointer)
+	for i := 0; i < 10000; i++ {
+		k := next()
+		v := next()
+		m[k] = v
+		c.Put(k, v)
+	}
+
+	// Overwrite a random 20% of those.
+	n := 0
+	for k := range m {
+		v := next()
+		m[k] = v
+		c.Put(k, v)
+		if n++; n >= 2000 {
+			break
+		}
+	}
+
+	// Check results.
+	str := func(p unsafe.Pointer) string {
+		if p == nil {
+			return "nil"
+		}
+		return fmt.Sprint(*(*int)(p))
+	}
+	for k, v := range m {
+		if cv := c.Get(k); cv != v {
+			t.Fatalf("c.Get(%v) = %v, want %v", str(k), str(cv), str(v))
+		}
+	}
+
+	c.Clear()
+	for k := range m {
+		if cv := c.Get(k); cv != nil {
+			t.Fatalf("after GC, c.Get(%v) = %v, want nil", str(k), str(cv))
+		}
+	}
+
+	// Check that registered cache is cleared at GC.
+	c = &registeredCache
+	for k, v := range m {
+		c.Put(k, v)
+	}
+	runtime.GC()
+	for k := range m {
+		if cv := c.Get(k); cv != nil {
+			t.Fatalf("after Clear, c.Get(%v) = %v, want nil", str(k), str(cv))
+		}
+	}
+
+	// Check that cache works for concurrent access.
+	// Lists are discarded if they reach 1000 entries,
+	// and there are cacheSize list heads, so we should be
+	// able to do 100 * cacheSize entries with no problem at all.
+	c = new(Cache)
+	var barrier, wg sync.WaitGroup
+	const N = 100
+	barrier.Add(N)
+	wg.Add(N)
+	var lost int32
+	for i := 0; i < N; i++ {
+		go func() {
+			defer wg.Done()
+
+			m := make(map[unsafe.Pointer]unsafe.Pointer)
+			for j := 0; j < cacheSize; j++ {
+				k, v := next(), next()
+				m[k] = v
+				c.Put(k, v)
+			}
+			barrier.Done()
+			barrier.Wait()
+
+			for k, v := range m {
+				if cv := c.Get(k); cv != v {
+					t.Errorf("c.Get(%v) = %v, want %v", str(k), str(cv), str(v))
+					atomic.AddInt32(&lost, +1)
+				}
+			}
+		}()
+	}
+	wg.Wait()
+	if lost != 0 {
+		t.Errorf("lost %d entries", lost)
+	}
+}
diff --git a/src/crypto/internal/backend/bcache/stub.s b/src/crypto/internal/backend/bcache/stub.s
new file mode 100644
index 00000000000..d2a6c5d6b84
--- /dev/null
+++ b/src/crypto/internal/backend/bcache/stub.s
@@ -0,0 +1,10 @@
+// Copyright 2017 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// registerCache is declared in cache.go without a body.
+// It's provided by package runtime,
+// but the go command doesn't know that.
+// Having this assembly file keeps the go command
+// from complaining about the missing body
+// (because the implementation might be here).
diff --git a/src/crypto/internal/backend/common.go b/src/crypto/internal/backend/common.go
new file mode 100644
index 00000000000..11ac2df4089
--- /dev/null
+++ b/src/crypto/internal/backend/common.go
@@ -0,0 +1,34 @@
+// Copyright 2022 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build !cmd_go_bootstrap && !msan
+
+package backend
+
+import (
+	"runtime"
+	"syscall"
+)
+
+func init() {
+	if v, _ := envGoFIPS(); v == "1" {
+		if runtime.GOOS != "linux" {
+			panic("FIPS mode requested (GOFIPS=1) but not supported on " + runtime.GOOS)
+		} else if !iscgo {
+			panic("FIPS mode requested (GOFIPS=1) but not supported with cgo disabled")
+		}
+	}
+}
+
+func envGoFIPS() (string, bool) {
+	if v, ok := syscall.Getenv("GOFIPS"); ok {
+		return v, true
+	}
+	// TODO: Decide which environment variable to use.
+	// See https://github.com/microsoft/go/issues/397.
+	if v, ok := syscall.Getenv("GOLANG_FIPS"); ok {
+		return v, true
+	}
+	return "", false
+}
diff --git a/src/crypto/internal/backend/iscgo.go b/src/crypto/internal/backend/iscgo.go
new file mode 100644
index 00000000000..1e0d3cf8c18
--- /dev/null
+++ b/src/crypto/internal/backend/iscgo.go
@@ -0,0 +1,10 @@
+// Copyright 2022 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build cgo
+// +build cgo
+
+package backend
+
+const iscgo = true
diff --git a/src/crypto/internal/backend/nobackend.go b/src/crypto/internal/backend/nobackend.go
new file mode 100644
index 00000000000..785e07ea6f4
--- /dev/null
+++ b/src/crypto/internal/backend/nobackend.go
@@ -0,0 +1,115 @@
+// Copyright 2017 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build (!boringcrypto && !goexperiment.opensslcrypto) || !linux || !cgo || android || cmd_go_bootstrap || msan
+
+package backend
+
+import (
+	"crypto"
+	"crypto/cipher"
+	"crypto/internal/boring/sig"
+	"hash"
+)
+
+const Enabled = false
+
+type BigInt []uint
+
+// Unreachable marks code that should be unreachable
+// when OpenSSLCrypto is in use. It is a no-op without OpenSSLCrypto.
+func Unreachable() {
+	// Code that's unreachable when using OpenSSLCrypto
+	// is exactly the code we want to detect for reporting
+	// standard Go crypto.
+	sig.StandardCrypto()
+}
+
+// UnreachableExceptTests marks code that should be unreachable
+// when OpenSSLCrypto is in use. It is a no-op without OpenSSLCrypto.
+func UnreachableExceptTests() {}
+
+type randReader int
+
+func (randReader) Read(b []byte) (int, error) { panic("opensslcrypto: not available") }
+
+const RandReader = randReader(0)
+
+func NewSHA1() hash.Hash   { panic("opensslcrypto: not available") }
+func NewSHA224() hash.Hash { panic("opensslcrypto: not available") }
+func NewSHA256() hash.Hash { panic("opensslcrypto: not available") }
+func NewSHA384() hash.Hash { panic("opensslcrypto: not available") }
+func NewSHA512() hash.Hash { panic("opensslcrypto: not available") }
+
+func SHA1(p []byte) (sum [20]byte)   { panic("opensslcrypto: not available") }
+func SHA224(p []byte) (sum [28]byte) { panic("opensslcrypto: not available") }
+func SHA256(p []byte) (sum [32]byte) { panic("opensslcrypto: not available") }
+func SHA384(p []byte) (sum [48]byte) { panic("opensslcrypto: not available") }
+func SHA512(p []byte) (sum [64]byte) { panic("opensslcrypto: not available") }
+
+func NewHMAC(h func() hash.Hash, key []byte) hash.Hash { panic("opensslcrypto: not available") }
+
+func NewAESCipher(key []byte) (cipher.Block, error) { panic("opensslcrypto: not available") }
+
+type PublicKeyECDSA struct{ _ int }
+type PrivateKeyECDSA struct{ _ int }
+
+func GenerateKeyECDSA(curve string) (X, Y, D BigInt, err error) {
+	panic("opensslcrypto: not available")
+}
+func NewPrivateKeyECDSA(curve string, X, Y, D BigInt) (*PrivateKeyECDSA, error) {
+	panic("opensslcrypto: not available")
+}
+func NewPublicKeyECDSA(curve string, X, Y BigInt) (*PublicKeyECDSA, error) {
+	panic("opensslcrypto: not available")
+}
+func SignMarshalECDSA(priv *PrivateKeyECDSA, hash []byte) ([]byte, error) {
+	panic("opensslcrypto: not available")
+}
+func VerifyECDSA(pub *PublicKeyECDSA, hash []byte, sig []byte) bool {
+	panic("opensslcrypto: not available")
+}
+
+type PublicKeyRSA struct{ _ int }
+type PrivateKeyRSA struct{ _ int }
+
+func DecryptRSAOAEP(h hash.Hash, priv *PrivateKeyRSA, ciphertext, label []byte) ([]byte, error) {
+	panic("opensslcrypto: not available")
+}
+func DecryptRSAPKCS1(priv *PrivateKeyRSA, ciphertext []byte) ([]byte, error) {
+	panic("opensslcrypto: not available")
+}
+func DecryptRSANoPadding(priv *PrivateKeyRSA, ciphertext []byte) ([]byte, error) {
+	panic("opensslcrypto: not available")
+}
+func EncryptRSAOAEP(h hash.Hash, pub *PublicKeyRSA, msg, label []byte) ([]byte, error) {
+	panic("opensslcrypto: not available")
+}
+func EncryptRSAPKCS1(pub *PublicKeyRSA, msg []byte) ([]byte, error) {
+	panic("opensslcrypto: not available")
+}
+func EncryptRSANoPadding(pub *PublicKeyRSA, msg []byte) ([]byte, error) {
+	panic("opensslcrypto: not available")
+}
+func GenerateKeyRSA(bits int) (N, E, D, P, Q, Dp, Dq, Qinv BigInt, err error) {
+	panic("opensslcrypto: not available")
+}
+func NewPrivateKeyRSA(N, E, D, P, Q, Dp, Dq, Qinv BigInt) (*PrivateKeyRSA, error) {
+	panic("opensslcrypto: not available")
+}
+func NewPublicKeyRSA(N, E BigInt) (*PublicKeyRSA, error) {
+	panic("opensslcrypto: not available")
+}
+func SignRSAPKCS1v15(priv *PrivateKeyRSA, h crypto.Hash, hashed []byte) ([]byte, error) {
+	panic("opensslcrypto: not available")
+}
+func SignRSAPSS(priv *PrivateKeyRSA, h crypto.Hash, hashed []byte, saltLen int) ([]byte, error) {
+	panic("opensslcrypto: not available")
+}
+func VerifyRSAPKCS1v15(pub *PublicKeyRSA, h crypto.Hash, hashed, sig []byte) error {
+	panic("opensslcrypto: not available")
+}
+func VerifyRSAPSS(pub *PublicKeyRSA, h crypto.Hash, hashed, sig []byte, saltLen int) error {
+	panic("opensslcrypto: not available")
+}
diff --git a/src/crypto/internal/backend/nocgo.go b/src/crypto/internal/backend/nocgo.go
new file mode 100644
index 00000000000..63c13fc4b01
--- /dev/null
+++ b/src/crypto/internal/backend/nocgo.go
@@ -0,0 +1,10 @@
+// Copyright 2022 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build !cgo
+// +build !cgo
+
+package backend
+
+const iscgo = false
diff --git a/src/crypto/internal/backend/openssl_linux.go b/src/crypto/internal/backend/openssl_linux.go
new file mode 100644
index 00000000000..4fb400ea521
--- /dev/null
+++ b/src/crypto/internal/backend/openssl_linux.go
@@ -0,0 +1,145 @@
+// Copyright 2017 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build goexperiment.opensslcrypto && linux && cgo && !android && !cmd_go_bootstrap && !msan
+
+// Package openssl provides access to OpenSSLCrypto implementation functions.
+// Check the variable Enabled to find out whether OpenSSLCrypto is available.
+// If OpenSSLCrypto is not available, the functions in this package all panic.
+package backend
+
+import (
+	"crypto/internal/boring/sig"
+	"syscall"
+
+	"github.com/microsoft/go-crypto-openssl/openssl"
+)
+
+// Enabled controls whether FIPS crypto is enabled.
+var Enabled = false
+
+func init() {
+	if !needFIPS() {
+		return
+	}
+	err := openssl.Init()
+	if err != nil {
+		panic(err)
+	}
+
+	if !openssl.FIPS() {
+		if err = openssl.SetFIPS(true); err != nil {
+			panic(err)
+		}
+	}
+
+	Enabled = true
+	sig.BoringCrypto()
+}
+
+func needFIPS() bool {
+	if v, ok := envGoFIPS(); ok {
+		return v != "0"
+	}
+	var fd int
+	for {
+		var err error
+		fd, err = syscall.Open("/proc/sys/crypto/fips_enabled", syscall.O_RDONLY, 0)
+		if err == nil {
+			break
+		}
+		switch err {
+		case syscall.EINTR:
+			continue
+		case syscall.ENOENT:
+			return false
+		default:
+			// If there is an error reading we could either panic or assume FIPS is not enabled.
+			// Panicking would be too disruptive for apps that don't require FIPS.
+			// If an app wants to be 100% sure that is running in FIPS mode
+			// it should use boring.Enabled() or GOFIPS=1.
+			return false
+		}
+	}
+	defer syscall.Close(fd)
+	var tmp [1]byte
+	n, err := syscall.Read(fd, tmp[:])
+	if n != 1 || err != nil {
+		// We return false instead of panicing for the same reason as before.
+		return false
+	}
+	// fips_enabled can be either '0' or '1'.
+	return tmp[0] == '1'
+}
+
+// Unreachable marks code that should be unreachable
+// when OpenSSLCrypto is in use. It panics only when
+// the system is in FIPS mode.
+func Unreachable() {
+	if Enabled {
+		panic("opensslcrypto: invalid code execution")
+	}
+}
+
+// Provided by runtime.crypto_backend_runtime_arg0 to avoid os import.
+func runtime_arg0() string
+
+func hasSuffix(s, t string) bool {
+	return len(s) > len(t) && s[len(s)-len(t):] == t
+}
+
+// UnreachableExceptTests marks code that should be unreachable
+// when OpenSSLCrypto is in use. It panics.
+func UnreachableExceptTests() {
+	name := runtime_arg0()
+	// If OpenSSLCrypto ran on Windows we'd need to allow _test.exe and .test.exe as well.
+	if Enabled && !hasSuffix(name, "_test") && !hasSuffix(name, ".test") {
+		println("opensslcrypto: unexpected code execution in", name)
+		panic("opensslcrypto: invalid code execution")
+	}
+}
+
+const RandReader = openssl.RandReader
+
+var NewSHA1 = openssl.NewSHA1
+var NewSHA224 = openssl.NewSHA224
+var NewSHA256 = openssl.NewSHA256
+var NewSHA384 = openssl.NewSHA384
+var NewSHA512 = openssl.NewSHA512
+
+var SHA1 = openssl.SHA1
+var SHA224 = openssl.SHA224
+var SHA256 = openssl.SHA256
+var SHA384 = openssl.SHA384
+var SHA512 = openssl.SHA512
+
+var NewHMAC = openssl.NewHMAC
+
+var NewAESCipher = openssl.NewAESCipher
+
+type PublicKeyECDSA = openssl.PublicKeyECDSA
+type PrivateKeyECDSA = openssl.PrivateKeyECDSA
+
+var GenerateKeyECDSA = openssl.GenerateKeyECDSA
+var NewPrivateKeyECDSA = openssl.NewPrivateKeyECDSA
+var NewPublicKeyECDSA = openssl.NewPublicKeyECDSA
+var SignMarshalECDSA = openssl.SignMarshalECDSA
+var VerifyECDSA = openssl.VerifyECDSA
+
+type PublicKeyRSA = openssl.PublicKeyRSA
+type PrivateKeyRSA = openssl.PrivateKeyRSA
+
+var DecryptRSAOAEP = openssl.DecryptRSAOAEP
+var DecryptRSAPKCS1 = openssl.DecryptRSAPKCS1
+var DecryptRSANoPadding = openssl.DecryptRSANoPadding
+var EncryptRSAOAEP = openssl.EncryptRSAOAEP
+var EncryptRSAPKCS1 = openssl.EncryptRSAPKCS1
+var EncryptRSANoPadding = openssl.EncryptRSANoPadding
+var GenerateKeyRSA = openssl.GenerateKeyRSA
+var NewPrivateKeyRSA = openssl.NewPrivateKeyRSA
+var NewPublicKeyRSA = openssl.NewPublicKeyRSA
+var SignRSAPKCS1v15 = openssl.SignRSAPKCS1v15
+var SignRSAPSS = openssl.SignRSAPSS
+var VerifyRSAPKCS1v15 = openssl.VerifyRSAPKCS1v15
+var VerifyRSAPSS = openssl.VerifyRSAPSS
diff --git a/src/crypto/internal/backend/stub.s b/src/crypto/internal/backend/stub.s
new file mode 100644
index 00000000000..157adeeeb37
--- /dev/null
+++ b/src/crypto/internal/backend/stub.s
@@ -0,0 +1,10 @@
+// Copyright 2017 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// runtime_arg0 is declared in openssl_linux.go without a body.
+// It's provided by package runtime,
+// but the go command doesn't know that.
+// Having this assembly file keeps the go command
+// from complaining about the missing body
+// (because the implementation might be here).
diff --git a/src/go.mod b/src/go.mod
index 2b4d8b4b753..893d681addc 100644
--- a/src/go.mod
+++ b/src/go.mod
@@ -3,6 +3,7 @@ module std
 go 1.19
 
 require (
+	github.com/microsoft/go-crypto-openssl v0.0.0-20220523161603-8a421b506065
 	golang.org/x/crypto v0.0.0-20220516162934-403b01795ae8
 	golang.org/x/net v0.0.0-20220517181318-183a9ca12b87
 )
diff --git a/src/go.sum b/src/go.sum
index 5c710268b85..839d6dddf5a 100644
--- a/src/go.sum
+++ b/src/go.sum
@@ -1,3 +1,5 @@
+github.com/microsoft/go-crypto-openssl v0.0.0-20220523161603-8a421b506065 h1:eBTac1GjUXGSxQkSjrmMJjx0wmlB/KKGMOBcPG7vWvM=
+github.com/microsoft/go-crypto-openssl v0.0.0-20220523161603-8a421b506065/go.mod h1:rC+rtBU3m60UCQifBmpWII0VETfu78w6YGZQvVc0rd4=
 golang.org/x/crypto v0.0.0-20220516162934-403b01795ae8 h1:y+mHpWoQJNAHt26Nhh6JP7hvM71IRZureyvZhoVALIs=
 golang.org/x/crypto v0.0.0-20220516162934-403b01795ae8/go.mod h1:IxCIyHEi3zRg3s0A5j5BB6A9Jmi73HwBIUl50j+osU4=
 golang.org/x/net v0.0.0-20220517181318-183a9ca12b87 h1:cCR+9mKLOGyX4Zx+uBZDXEDAQsvKQ/XbW4vreG5v1jU=
diff --git a/src/runtime/runtime_boring.go b/src/runtime/runtime_boring.go
index 5a98b202531..9042f2c2795 100644
--- a/src/runtime/runtime_boring.go
+++ b/src/runtime/runtime_boring.go
@@ -17,3 +17,8 @@ func boring_runtime_arg0() string {
 
 //go:linkname fipstls_runtime_arg0 crypto/internal/boring/fipstls.runtime_arg0
 func fipstls_runtime_arg0() string { return boring_runtime_arg0() }
+
+//go:linkname crypto_backend_runtime_arg0 crypto/internal/backend.runtime_arg0
+func crypto_backend_runtime_arg0() string {
+	return boring_runtime_arg0()
+}
