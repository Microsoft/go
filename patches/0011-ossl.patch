From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: qmuntal <qmuntaldiaz@microsoft.com>
Date: Fri, 31 Jan 2025 10:06:33 +0100
Subject: [PATCH] ossl

---
 .../internal/backend/fips140/openssl.go       |  20 +++-
 .../internal/opensslsetup/opensslsetup.go     |  72 ++++++++++++
 .../opensslsetup/opensslsetup_test.go         | 104 ++++++++++++++++++
 src/crypto/internal/backend/openssl_linux.go  |  30 +----
 src/go/build/deps_test.go                     |  28 +++--
 5 files changed, 215 insertions(+), 39 deletions(-)
 create mode 100644 src/crypto/internal/backend/internal/opensslsetup/opensslsetup.go
 create mode 100644 src/crypto/internal/backend/internal/opensslsetup/opensslsetup_test.go

diff --git a/src/crypto/internal/backend/fips140/openssl.go b/src/crypto/internal/backend/fips140/openssl.go
index 2d126bcfc053de..1af7a36c0ffd59 100644
--- a/src/crypto/internal/backend/fips140/openssl.go
+++ b/src/crypto/internal/backend/fips140/openssl.go
@@ -6,9 +6,25 @@
 
 package fips140
 
-import "syscall"
+import (
+	_ "crypto/internal/backend/internal/opensslsetup"
+	"syscall"
 
+	"github.com/golang-fips/openssl/v2"
+)
+
+// systemFIPSMode reports whether the system is in FIPS mode.
+// It first checks the kernel, and if that is not available, it checks the
+// OpenSSL library.
 func systemFIPSMode() bool {
+	if kernelFIPSMode() {
+		return true
+	}
+	return openssl.FIPS()
+}
+
+// kernelFIPSMode reports whether the kernel is in FIPS mode.
+func kernelFIPSMode() bool {
 	var fd int
 	for {
 		var err error
@@ -25,7 +41,7 @@ func systemFIPSMode() bool {
 			// If there is an error reading we could either panic or assume FIPS is not enabled.
 			// Panicking would be too disruptive for apps that don't require FIPS.
 			// If an app wants to be 100% sure that is running in FIPS mode
-			// it should use boring.Enabled() or GODEBUG=fips140=1.
+			// it should use fips140.Enabled() or GODEBUG=fips140=1.
 			return false
 		}
 	}
diff --git a/src/crypto/internal/backend/internal/opensslsetup/opensslsetup.go b/src/crypto/internal/backend/internal/opensslsetup/opensslsetup.go
new file mode 100644
index 00000000000000..fdce6758018c5c
--- /dev/null
+++ b/src/crypto/internal/backend/internal/opensslsetup/opensslsetup.go
@@ -0,0 +1,72 @@
+// Copyright 2025 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build goexperiment.opensslcrypto
+
+// opensslsetup is a package that initializes the OpenSSL library.
+// It doesn't export any symbol, but blank importing it has the
+// side effect of initializing the OpenSSL library.
+
+package opensslsetup
+
+import (
+	"syscall"
+
+	"github.com/golang-fips/openssl/v2"
+)
+
+// knownVersions is a list of supported and well-known libcrypto.so suffixes in decreasing version order.
+// FreeBSD library version numbering does not directly align to the version of OpenSSL.
+// Its preferred search order is 11 -> 111.
+// Some distributions use 1.0.0 and others (such as Debian) 1.0.2 to refer to the same OpenSSL 1.0.2 version.
+// Fedora derived distros use different naming for the version 1.0.x.
+var knownVersions = [...]string{"3", "1.1", "11", "111", "1.0.2", "1.0.0", "10"}
+
+const lcryptoPrefix = "libcrypto.so."
+
+func init() {
+	lib := library()
+	if err := openssl.Init(lib); err != nil {
+		panic("opensslcrypto: can't initialize OpenSSL " + lcrypto + ": " + err.Error())
+	}
+}
+
+// library returns the name of the OpenSSL library to use.
+// It first checks the environment variable GO_OPENSSL_VERSION_OVERRIDE.
+// If that is not set, it searches a well-known list of library names.
+// If no library is found, it returns "libcrypto.so".
+func library() string {
+	if version, _ := syscall.Getenv("GO_OPENSSL_VERSION_OVERRIDE"); version != "" {
+		return lcryptoPrefix + version
+	}
+	lcrypto = searchKnownLibrary()
+	if lcrypto != "" {
+		return lcrypto
+	}
+	return lcryptoPrefix[:len(lcryptoPrefix)-1] // no version found, try without version suffix
+}
+
+// checkVersion is a variable that holds the openssl.CheckVersion function.
+// It is initialized in the init function to allow overriding in tests.
+var checkVersion = openssl.CheckVersion
+
+// searchKnownLibrary returns the name of the highest available FIPS-enabled version of OpenSSL
+// using the known library suffixes.
+// If no FIPS-enabled version is found, it returns the name of the highest available version.
+// If no version is found, it returns an empty string.
+func searchKnownLibrary() string {
+	var lcryptoFallback string
+	for _, v := range knownVersions {
+		lcryptoCandidate := lcryptoPrefix + v
+		if exists, fips := checkVersion(lcryptoCandidate); exists {
+			if fips {
+				return lcryptoCandidate
+			}
+			if lcryptoFallback == "" {
+				lcryptoFallback = lcryptoCandidate
+			}
+		}
+	}
+	return lcryptoFallback
+}
diff --git a/src/crypto/internal/backend/internal/opensslsetup/opensslsetup_test.go b/src/crypto/internal/backend/internal/opensslsetup/opensslsetup_test.go
new file mode 100644
index 00000000000000..8ff53752da23f0
--- /dev/null
+++ b/src/crypto/internal/backend/internal/opensslsetup/opensslsetup_test.go
@@ -0,0 +1,104 @@
+// Copyright 2025 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build goexperiment.opensslcrypto
+
+package opensslsetup
+
+import (
+	"os"
+	"testing"
+
+	"github.com/golang-fips/openssl/v2"
+)
+
+// Mock the openssl.CheckVersion function
+var checkVersionMock = func(lib string) (exists bool, fips bool) {
+	switch lib {
+	case "libcrypto.so.3":
+		return true, true
+	case "libcrypto.so.1.1":
+		return true, false
+	case "libcrypto.so.111":
+		return true, false
+	case "libcrypto.so.1.0.2":
+		return true, false
+	case "libcrypto.so.1.0.0":
+		return true, false
+	case "libcrypto.so.10":
+		return true, false
+	default:
+		return false, false
+	}
+}
+
+func init() {
+	checkVersion = checkVersionMock
+}
+
+func TestLibraryWithEnvOverride(t *testing.T) {
+	os.Setenv("GO_OPENSSL_VERSION_OVERRIDE", "1.1")
+	defer os.Unsetenv("GO_OPENSSL_VERSION_OVERRIDE")
+
+	expected := "libcrypto.so.1.1"
+	result := library()
+	if result != expected {
+		t.Errorf("expected %s, got %s", expected, result)
+	}
+}
+
+func TestLibraryWithKnownVersion(t *testing.T) {
+	os.Unsetenv("GO_OPENSSL_VERSION_OVERRIDE")
+
+	expected := "libcrypto.so.3"
+	result := library()
+	if result != expected {
+		t.Errorf("expected %s, got %s", expected, result)
+	}
+}
+
+func TestLibraryFallback(t *testing.T) {
+	os.Unsetenv("GO_OPENSSL_VERSION_OVERRIDE")
+
+	// Modify the mock to simulate no FIPS-enabled version found
+	openssl.CheckVersion = func(lib string) (exists bool, fips bool) {
+		switch lib {
+		case "libcrypto.so.3":
+			return true, false
+		case "libcrypto.so.1.1":
+			return true, false
+		case "libcrypto.so.111":
+			return true, false
+		case "libcrypto.so.1.0.2":
+			return true, false
+		case "libcrypto.so.1.0.0":
+			return true, false
+		case "libcrypto.so.10":
+			return true, false
+		default:
+			return false, false
+		}
+	}
+
+	expected := "libcrypto.so.3"
+	result := library()
+	if result != expected {
+		t.Errorf("expected %s, got %s", expected, result)
+	}
+}
+
+func TestLibraryNoVersionFound(t *testing.T) {
+	os.Unsetenv("GO_OPENSSL_VERSION_OVERRIDE")
+
+	// Modify the mock to simulate no version found
+	openssl.CheckVersion = func(lib string) (exists bool, fips bool) {
+		return false, false
+	}
+
+	expected := "libcrypto.so"
+	result := library()
+	if result != expected {
+		t.Errorf("expected %s, got %s", expected, result)
+	}
+}
diff --git a/src/crypto/internal/backend/openssl_linux.go b/src/crypto/internal/backend/openssl_linux.go
index 414c043189f896..ad332c550825b6 100644
--- a/src/crypto/internal/backend/openssl_linux.go
+++ b/src/crypto/internal/backend/openssl_linux.go
@@ -13,9 +13,9 @@ import (
 	"crypto"
 	"crypto/cipher"
 	"crypto/internal/backend/fips140"
+	_ "crypto/internal/backend/internal/opensslsetup"
 	"crypto/internal/boring/sig"
 	"hash"
-	"syscall"
 
 	"github.com/golang-fips/openssl/v2"
 )
@@ -35,34 +35,6 @@ var knownVersions = [...]string{"3", "1.1", "11", "111", "1.0.2", "1.0.0", "10"}
 const lcryptoPrefix = "libcrypto.so."
 
 func init() {
-	var lcrypto string
-	if version, _ := syscall.Getenv("GO_OPENSSL_VERSION_OVERRIDE"); version != "" {
-		lcrypto = lcryptoPrefix + version
-	} else {
-		// Try to find the highest available FIPS-enabled version of OpenSSL
-		// using the known library suffixes.
-		var lcryptoFallback string
-		for _, v := range knownVersions {
-			lcryptoCandidate := lcryptoPrefix + v
-			if exists, fips := openssl.CheckVersion(lcryptoCandidate); exists {
-				if fips {
-					lcrypto = lcryptoCandidate
-					break
-				}
-				if lcryptoFallback == "" {
-					lcryptoFallback = lcryptoCandidate
-				}
-			}
-		}
-		if lcrypto == "" && lcryptoFallback != "" {
-			// There is no FIPS-enabled version of OpenSSL,
-			// use the highest available version.
-			lcrypto = lcryptoFallback
-		}
-	}
-	if err := openssl.Init(lcrypto); err != nil {
-		panic("opensslcrypto: can't initialize OpenSSL " + lcrypto + ": " + err.Error())
-	}
 	if fips140.Enabled() {
 		// Some distributions, e.g. Azure Linux 3, don't set the `fips=yes` property when running in FIPS mode,
 		// but they configure OpenSSL to use a FIPS-compliant provider (in the case of Azure Linux 3, the SCOSSL provider).
diff --git a/src/go/build/deps_test.go b/src/go/build/deps_test.go
index 484c95dfb65f60..87e92a5d6d1ee9 100644
--- a/src/go/build/deps_test.go
+++ b/src/go/build/deps_test.go
@@ -493,7 +493,22 @@ var depsRules = `
 	< crypto/internal/fips140/rsa
 	< FIPS;
 
-	syscall < crypto/internal/backend/fips140;
+	FIPS, hash < crypto/internal/fips140only;
+	crypto/internal/fips140/subtle,	hash < crypto;
+	crypto/internal/fips140/subtle < crypto/subtle;
+	crypto/subtle, crypto/internal/fips140only < crypto/cipher;
+
+	crypto,
+	crypto/subtle,
+	encoding/binary,
+	hash,
+	crypto/cipher
+	< github.com/golang-fips/openssl/v2;
+
+	syscall,
+	github.com/golang-fips/openssl/v2
+	< crypto/internal/backend/internal/opensslsetup
+	< crypto/internal/backend/fips140;
 
 	FIPS, internal/godebug, crypto/internal/backend/fips140 < crypto/fips140;
 
@@ -509,15 +524,12 @@ var depsRules = `
 	crypto/internal/boring/sig,
 	crypto/internal/boring/syso,
 	crypto/internal/boring/bcache,
-	crypto/internal/backend/fips140
-	< crypto/internal/fips140only
-	< crypto
-	< crypto/subtle
+	crypto/internal/backend/fips140,
+	crypto/internal/backend/internal/opensslsetup,
+	crypto/cipher,
+	crypto/internal/fips140only
 	< crypto/sha3
 	< crypto/internal/fips140hash
-	< crypto/cipher
-	< github.com/golang-fips/openssl/v2/internal/subtle
-	< github.com/golang-fips/openssl/v2
 	< github.com/microsoft/go-crypto-darwin/internal/cryptokit
 	< github.com/microsoft/go-crypto-darwin/xcrypto
 	< github.com/microsoft/go-crypto-winnative/internal/subtle
