From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: qmuntal <qmuntaldiaz@microsoft.com>
Date: Tue, 14 Jan 2025 11:10:21 +0100
Subject: [PATCH] Use crypto backends

---
 src/cmd/api/boring_test.go                    |   2 +-
 src/cmd/dist/test.go                          |   8 +-
 src/cmd/go/go_boring_test.go                  |  11 +-
 src/cmd/go/testdata/script/darwin_no_cgo.txt  |   2 +
 .../go/testdata/script/gopath_std_vendor.txt  |   9 +
 src/cmd/link/internal/ld/config.go            |   8 +
 src/cmd/link/internal/ld/lib.go               |   1 +
 src/crypto/aes/aes.go                         |   2 +-
 src/crypto/boring/boring.go                   |   4 +-
 src/crypto/cipher/ctr_aes_test.go             |   2 +-
 src/crypto/cipher/gcm_test.go                 |   2 +-
 src/crypto/des/cipher.go                      |   7 +
 src/crypto/dsa/boring.go                      | 113 +++++++++++
 src/crypto/dsa/dsa.go                         |  88 +++++++++
 src/crypto/dsa/notboring.go                   |  16 ++
 src/crypto/ecdh/ecdh.go                       |   2 +-
 src/crypto/ecdh/ecdh_test.go                  |   4 +
 src/crypto/ecdh/nist.go                       |   2 +-
 src/crypto/ecdsa/badlinkname.go               |  19 ++
 src/crypto/ecdsa/boring.go                    |   6 +-
 src/crypto/ecdsa/ecdsa.go                     |  10 +-
 src/crypto/ecdsa/notboring.go                 |   4 +-
 src/crypto/ed25519/boring.go                  |  71 +++++++
 src/crypto/ed25519/ed25519.go                 |  73 +++++++
 src/crypto/ed25519/ed25519_test.go            |   3 +-
 src/crypto/ed25519/notboring.go               |  16 ++
 src/crypto/fips140/fips140.go                 |   3 +-
 src/crypto/hkdf/hkdf.go                       |  14 ++
 src/crypto/hkdf/hkdf_test.go                  |   2 +-
 src/crypto/hmac/hmac.go                       |   2 +-
 src/crypto/hmac/hmac_test.go                  |   2 +-
 src/crypto/internal/cryptotest/allocations.go |   2 +-
 .../internal/cryptotest/implementations.go    |   2 +-
 src/crypto/internal/fips140test/check_test.go |   3 +-
 src/crypto/md5/md5.go                         |  10 +
 src/crypto/md5/md5_test.go                    |  16 ++
 src/crypto/pbkdf2/pbkdf2.go                   |   4 +
 src/crypto/pbkdf2/pbkdf2_test.go              |   2 +-
 src/crypto/purego_test.go                     |   2 +-
 src/crypto/rand/rand.go                       |   2 +-
 src/crypto/rc4/rc4.go                         |  18 ++
 src/crypto/rsa/boring.go                      |  12 +-
 src/crypto/rsa/boring_test.go                 |   2 +-
 src/crypto/rsa/darwin.go                      |  71 +++++++
 src/crypto/rsa/fips.go                        |  14 +-
 src/crypto/rsa/notboring.go                   |   4 +-
 src/crypto/rsa/pkcs1v15.go                    |   6 +-
 src/crypto/rsa/pkcs1v15_test.go               |   5 +
 src/crypto/rsa/pss_test.go                    |  13 +-
 src/crypto/rsa/rsa.go                         |   4 +-
 src/crypto/rsa/rsa_test.go                    |  15 +-
 src/crypto/sha1/sha1.go                       |   8 +-
 src/crypto/sha1/sha1_test.go                  |   9 +-
 src/crypto/sha256/sha256.go                   |   6 +-
 src/crypto/sha256/sha256_test.go              |  16 ++
 src/crypto/sha512/sha512.go                   |   2 +-
 src/crypto/sha512/sha512_test.go              |  16 ++
 src/crypto/tls/cipher_suites.go               |   2 +-
 src/crypto/tls/fipsonly/fipsonly.go           |   2 +-
 src/crypto/tls/fipsonly/fipsonly_test.go      |   2 +-
 src/crypto/tls/handshake_client.go            |  12 +-
 src/crypto/tls/handshake_client_tls13.go      |  16 +-
 src/crypto/tls/handshake_server.go            |  10 +-
 src/crypto/tls/handshake_server_tls13.go      |  27 ++-
 src/crypto/tls/internal/fips140tls/fipstls.go |   4 +-
 src/crypto/tls/internal/tls13/doc.go          |  18 ++
 src/crypto/tls/internal/tls13/tls13.go        | 182 ++++++++++++++++++
 src/crypto/tls/key_schedule.go                |   2 +-
 src/crypto/tls/prf.go                         |  41 ++++
 src/go/build/deps_test.go                     |   5 +-
 src/hash/boring_test.go                       |   9 +
 src/hash/example_test.go                      |   2 +
 src/hash/marshal_test.go                      |   4 +
 src/hash/notboring_test.go                    |   9 +
 src/net/lookup_test.go                        |   3 +
 src/net/smtp/smtp_test.go                     |  72 ++++---
 src/os/exec/exec_test.go                      |   9 +
 src/runtime/pprof/vminfo_darwin_test.go       |   6 +
 78 files changed, 1099 insertions(+), 110 deletions(-)
 create mode 100644 src/crypto/dsa/boring.go
 create mode 100644 src/crypto/dsa/notboring.go
 create mode 100644 src/crypto/ecdsa/badlinkname.go
 create mode 100644 src/crypto/ed25519/boring.go
 create mode 100644 src/crypto/ed25519/notboring.go
 create mode 100644 src/crypto/rsa/darwin.go
 create mode 100644 src/crypto/tls/internal/tls13/doc.go
 create mode 100644 src/crypto/tls/internal/tls13/tls13.go
 create mode 100644 src/hash/boring_test.go
 create mode 100644 src/hash/notboring_test.go

diff --git a/src/cmd/api/boring_test.go b/src/cmd/api/boring_test.go
index f0e3575637c62a..9eab3b4e66e60b 100644
--- a/src/cmd/api/boring_test.go
+++ b/src/cmd/api/boring_test.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto
+//go:build goexperiment.systemcrypto
 
 package main
 
diff --git a/src/cmd/dist/test.go b/src/cmd/dist/test.go
index 0c992118f4287b..3316bb52a61ff1 100644
--- a/src/cmd/dist/test.go
+++ b/src/cmd/dist/test.go
@@ -1161,6 +1161,11 @@ func (t *tester) internalLink() bool {
 	if goos == "windows" && goarch == "arm64" {
 		return false
 	}
+	if goos == "darwin" && (strings.Contains(goexperiment, "systemcrypto") || strings.Contains(goexperiment, "darwincrypto")) {
+		// linkmode=internal isn't supported with system/darwin crypto.
+		// see https://github.com/microsoft/go-crypto-darwin/issues/33
+		return false
+	}
 	// Internally linking cgo is incomplete on some architectures.
 	// https://golang.org/issue/10373
 	// https://golang.org/issue/14449
@@ -1324,12 +1329,11 @@ func (t *tester) registerCgoTests(heading string) {
 			// a C linker warning on Linux.
 			// in function `bio_ip_and_port_to_socket_and_addr':
 			// warning: Using 'getaddrinfo' in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
-			if staticCheck.skip == nil && goos == "linux" && strings.Contains(goexperiment, "boringcrypto") {
+			if staticCheck.skip == nil && goos == "linux" && (strings.Contains(goexperiment, "boringcrypto") || strings.Contains(goexperiment, "opensslcrypto")) {
 				staticCheck.skip = func(*distTest) (string, bool) {
 					return "skipping static linking check on Linux when using boringcrypto to avoid C linker warning about getaddrinfo", true
 				}
 			}
-
 			// Static linking tests
 			if goos != "android" && p != "netbsd/arm" && !t.msan && !t.asan {
 				// TODO(#56629): Why does this fail on netbsd-arm?
diff --git a/src/cmd/go/go_boring_test.go b/src/cmd/go/go_boring_test.go
index ed0fbf3d53d75b..8111b143a1295b 100644
--- a/src/cmd/go/go_boring_test.go
+++ b/src/cmd/go/go_boring_test.go
@@ -2,13 +2,20 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto
+//go:build goexperiment.systemcrypto
 
 package main_test
 
-import "testing"
+import (
+	"internal/goexperiment"
+	"testing"
+)
 
 func TestBoringInternalLink(t *testing.T) {
+	if goexperiment.DarwinCrypto {
+		// https://github.com/microsoft/go-crypto-darwin/issues/33
+		t.Skip("skipping on Darwin")
+	}
 	tg := testgo(t)
 	defer tg.cleanup()
 	tg.parallel()
diff --git a/src/cmd/go/testdata/script/darwin_no_cgo.txt b/src/cmd/go/testdata/script/darwin_no_cgo.txt
index fa445925b7c374..e36ac86fcaa58d 100644
--- a/src/cmd/go/testdata/script/darwin_no_cgo.txt
+++ b/src/cmd/go/testdata/script/darwin_no_cgo.txt
@@ -4,6 +4,8 @@
 # of cmd/go, which imports approximately everything
 # in std (certainly everything relevant).
 [!GOOS:darwin] skip
+[GOEXPERIMENT:darwincrypto] skip
+[GOEXPERIMENT:systemcrypto] skip
 go list -deps cmd/go
 ! stdout runtime/cgo
 
diff --git a/src/cmd/go/testdata/script/gopath_std_vendor.txt b/src/cmd/go/testdata/script/gopath_std_vendor.txt
index 4aaf46b5d0f0dc..ec58a217400caa 100644
--- a/src/cmd/go/testdata/script/gopath_std_vendor.txt
+++ b/src/cmd/go/testdata/script/gopath_std_vendor.txt
@@ -1,5 +1,14 @@
 env GO111MODULE=off
 
+# Disable systemcrypto while evaluating test dependencies to avoid importing
+# vendored crypto module dependencies like golang-fips/openssl. This test script
+# is not set up to handle any vendored libraries being imported other than
+# golang.org/x/net/http2/hpack, so we must make sure it is the only one.
+#
+# See https://github.com/microsoft/go/issues/481 for more details, such as the
+# dependency chain that would cause the failure if the gocrypt tag isn't used.
+env GOEXPERIMENT=none
+
 [!compiler:gc] skip
 
 go list -f '{{.Dir}}' vendor/golang.org/x/net/http2/hpack
diff --git a/src/cmd/link/internal/ld/config.go b/src/cmd/link/internal/ld/config.go
index b2d4ad7cb0e7f6..2859879041ff8f 100644
--- a/src/cmd/link/internal/ld/config.go
+++ b/src/cmd/link/internal/ld/config.go
@@ -7,6 +7,7 @@ package ld
 import (
 	"fmt"
 	"internal/buildcfg"
+	"internal/goexperiment"
 	"internal/platform"
 )
 
@@ -34,6 +35,13 @@ func (mode *BuildMode) Set(s string) error {
 		return fmt.Errorf("invalid buildmode: %q", s)
 	case "exe":
 		switch buildcfg.GOOS + "/" + buildcfg.GOARCH {
+		case "darwin/amd64":
+			// We can't link against the static object file when using no_pie
+			if goexperiment.DarwinCrypto || goexperiment.SystemCrypto {
+				*mode = BuildModePIE
+			} else {
+				*mode = BuildModeExe
+			}
 		case "darwin/arm64", "windows/arm", "windows/arm64": // On these platforms, everything is PIE
 			*mode = BuildModePIE
 		default:
diff --git a/src/cmd/link/internal/ld/lib.go b/src/cmd/link/internal/ld/lib.go
index 2d8f964f3594c6..a587e1abde57c9 100644
--- a/src/cmd/link/internal/ld/lib.go
+++ b/src/cmd/link/internal/ld/lib.go
@@ -1172,6 +1172,7 @@ var hostobj []Hostobj
 // These packages can use internal linking mode.
 // Others trigger external mode.
 var internalpkg = []string{
+	"vendor/github.com/golang-fips/openssl/v2",
 	"crypto/internal/boring",
 	"crypto/internal/boring/syso",
 	"crypto/x509",
diff --git a/src/crypto/aes/aes.go b/src/crypto/aes/aes.go
index 5bc2d13d673e0a..b803c77be62a66 100644
--- a/src/crypto/aes/aes.go
+++ b/src/crypto/aes/aes.go
@@ -15,7 +15,7 @@ package aes
 
 import (
 	"crypto/cipher"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140/aes"
 	"strconv"
 )
diff --git a/src/crypto/boring/boring.go b/src/crypto/boring/boring.go
index 097c37e343fdb8..a5d603896d3890 100644
--- a/src/crypto/boring/boring.go
+++ b/src/crypto/boring/boring.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto
+//go:build goexperiment.systemcrypto
 
 // Package boring exposes functions that are only available when building with
 // Go+BoringCrypto. This package is available on all targets as long as the
@@ -13,7 +13,7 @@
 // is satisfied, so that applications can tag files that use this package.
 package boring
 
-import "crypto/internal/boring"
+import boring "crypto/internal/backend"
 
 // Enabled reports whether BoringCrypto handles supported crypto operations.
 func Enabled() bool {
diff --git a/src/crypto/cipher/ctr_aes_test.go b/src/crypto/cipher/ctr_aes_test.go
index 33942467784ad3..0282ffa9fa23c8 100644
--- a/src/crypto/cipher/ctr_aes_test.go
+++ b/src/crypto/cipher/ctr_aes_test.go
@@ -14,7 +14,7 @@ import (
 	"bytes"
 	"crypto/aes"
 	"crypto/cipher"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/cryptotest"
 	fipsaes "crypto/internal/fips140/aes"
 	"encoding/hex"
diff --git a/src/crypto/cipher/gcm_test.go b/src/crypto/cipher/gcm_test.go
index ea2b4e29e2b67f..f884b0d0fbefe7 100644
--- a/src/crypto/cipher/gcm_test.go
+++ b/src/crypto/cipher/gcm_test.go
@@ -8,7 +8,7 @@ import (
 	"bytes"
 	"crypto/aes"
 	"crypto/cipher"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/cryptotest"
 	"crypto/internal/fips140"
 	fipsaes "crypto/internal/fips140/aes"
diff --git a/src/crypto/des/cipher.go b/src/crypto/des/cipher.go
index 21303b384cf757..0d3c4f810cfd8f 100644
--- a/src/crypto/des/cipher.go
+++ b/src/crypto/des/cipher.go
@@ -6,6 +6,7 @@ package des
 
 import (
 	"crypto/cipher"
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140/alias"
 	"crypto/internal/fips140only"
 	"errors"
@@ -36,6 +37,9 @@ func NewCipher(key []byte) (cipher.Block, error) {
 	if len(key) != 8 {
 		return nil, KeySizeError(len(key))
 	}
+	if boring.Enabled && boring.SupportsDESCipher() {
+		return boring.NewDESCipher(key)
+	}
 
 	c := new(desCipher)
 	c.generateSubkeys(key)
@@ -84,6 +88,9 @@ func NewTripleDESCipher(key []byte) (cipher.Block, error) {
 	if len(key) != 24 {
 		return nil, KeySizeError(len(key))
 	}
+	if boring.Enabled && boring.SupportsTripleDESCipher() {
+		return boring.NewTripleDESCipher(key)
+	}
 
 	c := new(tripleDESCipher)
 	c.cipher1.generateSubkeys(key[:8])
diff --git a/src/crypto/dsa/boring.go b/src/crypto/dsa/boring.go
new file mode 100644
index 00000000000000..7ea0c8c423e9ee
--- /dev/null
+++ b/src/crypto/dsa/boring.go
@@ -0,0 +1,113 @@
+// Copyright 2017 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build goexperiment.systemcrypto
+
+package dsa
+
+import (
+	boring "crypto/internal/backend"
+	"crypto/internal/backend/bbig"
+	"crypto/internal/boring/bcache"
+	"math/big"
+)
+
+// Cached conversions from Go PublicKey/PrivateKey to BoringCrypto.
+//
+// The first operation on a PublicKey or PrivateKey makes a parallel
+// BoringCrypto key and saves it in pubCache or privCache.
+//
+// We could just assume that once used in a sign/verify/encrypt/decrypt operation,
+// a particular key is never again modified, but that has not been a
+// stated assumption before. Just in case there is any existing code that
+// does modify the key between operations, we save the original values
+// alongside the cached BoringCrypto key and check that the real key
+// still matches before using the cached key. The theory is that the real
+// operations are significantly more expensive than the comparison.
+
+type boringPub struct {
+	key  *boring.PublicKeyDSA
+	orig PublicKey
+}
+
+var pubCache bcache.Cache[PublicKey, boringPub]
+var privCache bcache.Cache[PrivateKey, boringPriv]
+
+func init() {
+	pubCache.Register()
+	privCache.Register()
+}
+
+func boringPublicKey(pub *PublicKey) (*boring.PublicKeyDSA, error) {
+	b := pubCache.Get(pub)
+	if b != nil && publicKeyEqual(&b.orig, pub) {
+		return b.key, nil
+	}
+
+	b = new(boringPub)
+	b.orig = copyPublicKey(pub)
+	key, err := boring.NewPublicKeyDSA(bbig.Enc(b.orig.P), bbig.Enc(b.orig.Q), bbig.Enc(b.orig.G), bbig.Enc(b.orig.Y))
+	if err != nil {
+		return nil, err
+	}
+	b.key = key
+	pubCache.Put(pub, b)
+	return key, nil
+}
+
+type boringPriv struct {
+	key  *boring.PrivateKeyDSA
+	orig PrivateKey
+}
+
+func boringPrivateKey(priv *PrivateKey) (*boring.PrivateKeyDSA, error) {
+	b := privCache.Get(priv)
+	if b != nil && privateKeyEqual(&b.orig, priv) {
+		return b.key, nil
+	}
+
+	b = new(boringPriv)
+	b.orig = copyPrivateKey(priv)
+
+	P := b.orig.P
+	Q := b.orig.Q
+	G := b.orig.G
+	X := b.orig.X
+	Y := b.orig.Y
+
+	key, err := boring.NewPrivateKeyDSA(bbig.Enc(P), bbig.Enc(Q), bbig.Enc(G), bbig.Enc(X), bbig.Enc(Y))
+	if err != nil {
+		return nil, err
+	}
+	b.key = key
+	privCache.Put(priv, b)
+	return key, nil
+}
+
+func publicKeyEqual(k1, k2 *PublicKey) bool {
+	return k1.Y != nil && k1.Y.Cmp(k2.Y) == 0 && k1.P.Cmp(k2.P) == 0 && k1.Q.Cmp(k2.Q) == 0 && k1.G.Cmp(k2.G) == 0
+}
+
+func copyPublicKey(k *PublicKey) PublicKey {
+	return PublicKey{
+		Parameters: Parameters{
+			P: new(big.Int).Set(k.P),
+			Q: new(big.Int).Set(k.Q),
+			G: new(big.Int).Set(k.G),
+		},
+		Y: new(big.Int).Set(k.Y),
+	}
+}
+
+func privateKeyEqual(k1, k2 *PrivateKey) bool {
+	return publicKeyEqual(&k1.PublicKey, &k2.PublicKey) &&
+		k1.X.Cmp(k2.X) == 0
+}
+
+func copyPrivateKey(k *PrivateKey) PrivateKey {
+	return PrivateKey{
+		PublicKey: copyPublicKey(&k.PublicKey),
+		X:         new(big.Int).Set(k.X),
+	}
+}
diff --git a/src/crypto/dsa/dsa.go b/src/crypto/dsa/dsa.go
index 000becc82dfb79..6430bb3ea5e437 100644
--- a/src/crypto/dsa/dsa.go
+++ b/src/crypto/dsa/dsa.go
@@ -18,8 +18,13 @@ import (
 	"io"
 	"math/big"
 
+	boring "crypto/internal/backend"
+	"crypto/internal/backend/bbig"
 	"crypto/internal/fips140only"
 	"crypto/internal/randutil"
+
+	"golang.org/x/crypto/cryptobyte"
+	"golang.org/x/crypto/cryptobyte/asn1"
 )
 
 // Parameters represents the domain parameters for a key. These parameters can
@@ -91,6 +96,17 @@ func GenerateParameters(params *Parameters, rand io.Reader, sizes ParameterSizes
 		return errors.New("crypto/dsa: invalid ParameterSizes")
 	}
 
+	if boring.Enabled && boring.SupportsDSA(L, N) {
+		p, q, g, err := boring.GenerateParametersDSA(L, N)
+		if err != nil {
+			return err
+		}
+		params.P = bbig.Dec(p)
+		params.Q = bbig.Dec(q)
+		params.G = bbig.Dec(g)
+		return nil
+	}
+
 	qBytes := make([]byte, N/8)
 	pBytes := make([]byte, L/8)
 
@@ -170,6 +186,17 @@ func GenerateKey(priv *PrivateKey, rand io.Reader) error {
 		return errors.New("crypto/dsa: parameters not set up before generating key")
 	}
 
+	if boring.Enabled && boring.SupportsDSA(priv.P.BitLen(), priv.Q.BitLen()) {
+		x, y, err := boring.GenerateKeyDSA(bbig.Enc(priv.P), bbig.Enc(priv.Q), bbig.Enc(priv.G))
+		if err != nil {
+			return err
+		}
+		priv.X = bbig.Dec(x)
+		priv.Y = bbig.Dec(y)
+
+		return nil
+	}
+
 	x := new(big.Int)
 	xBytes := make([]byte, priv.Q.BitLen()/8)
 
@@ -225,6 +252,18 @@ func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err err
 		err = ErrInvalidPublicKey
 		return
 	}
+
+	if boring.Enabled && boring.SupportsDSA(priv.P.BitLen(), priv.Q.BitLen()) {
+		b, err := boringPrivateKey(priv)
+		if err != nil {
+			return nil, nil, err
+		}
+
+		r, s, err := boring.SignDSA(b, hash, parseSignature)
+
+		return bbig.Dec(r), bbig.Dec(s), err
+	}
+
 	n >>= 3
 
 	var attempts int
@@ -288,6 +327,14 @@ func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool {
 		panic("crypto/dsa: use of DSA is not allowed in FIPS 140-only mode")
 	}
 
+	if boring.Enabled && boring.SupportsDSA(pub.P.BitLen(), pub.Q.BitLen()) {
+		bkey, err := boringPublicKey(pub)
+		if err != nil {
+			return false
+		}
+
+		return boring.VerifyDSA(bkey, hash, bbig.Enc(r), bbig.Enc(s), encodeSignature)
+	}
 	// FIPS 186-3, section 4.7
 
 	if pub.P.Sign() == 0 {
@@ -324,3 +371,44 @@ func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool {
 
 	return v.Cmp(r) == 0
 }
+
+func parseSignature(sig []byte) (boring.BigInt, boring.BigInt, error) {
+	var r, s []byte
+	var inner cryptobyte.String
+	input := cryptobyte.String(sig)
+	if !input.ReadASN1(&inner, asn1.SEQUENCE) ||
+		!input.Empty() ||
+		!inner.ReadASN1Integer(&r) ||
+		!inner.ReadASN1Integer(&s) ||
+		!inner.Empty() {
+		return nil, nil, errors.New("invalid ASN.1")
+	}
+	return bbig.Enc(new(big.Int).SetBytes(r)), bbig.Enc(new(big.Int).SetBytes(s)), nil
+}
+
+func encodeSignature(r, s boring.BigInt) ([]byte, error) {
+	var b cryptobyte.Builder
+	b.AddASN1(asn1.SEQUENCE, func(b *cryptobyte.Builder) {
+		addASN1IntBytes(b, bbig.Dec(r).Bytes())
+		addASN1IntBytes(b, bbig.Dec(s).Bytes())
+	})
+	return b.Bytes()
+}
+
+// addASN1IntBytes encodes in ASN.1 a positive integer represented as
+// a big-endian byte slice with zero or more leading zeroes.
+func addASN1IntBytes(b *cryptobyte.Builder, bytes []byte) {
+	for len(bytes) > 0 && bytes[0] == 0 {
+		bytes = bytes[1:]
+	}
+	if len(bytes) == 0 {
+		b.SetError(errors.New("invalid integer"))
+		return
+	}
+	b.AddASN1(asn1.INTEGER, func(c *cryptobyte.Builder) {
+		if bytes[0]&0x80 != 0 {
+			c.AddUint8(0)
+		}
+		c.AddBytes(bytes)
+	})
+}
diff --git a/src/crypto/dsa/notboring.go b/src/crypto/dsa/notboring.go
new file mode 100644
index 00000000000000..cd02ff5a00c3dc
--- /dev/null
+++ b/src/crypto/dsa/notboring.go
@@ -0,0 +1,16 @@
+// Copyright 2022 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build !goexperiment.systemcrypto
+
+package dsa
+
+import boring "crypto/internal/backend"
+
+func boringPublicKey(*PublicKey) (*boring.PublicKeyDSA, error) {
+	panic("boringcrypto: not available")
+}
+func boringPrivateKey(*PrivateKey) (*boring.PrivateKeyDSA, error) {
+	panic("boringcrypto: not available")
+}
diff --git a/src/crypto/ecdh/ecdh.go b/src/crypto/ecdh/ecdh.go
index 231f1ea04c1010..cfa113e2345816 100644
--- a/src/crypto/ecdh/ecdh.go
+++ b/src/crypto/ecdh/ecdh.go
@@ -8,7 +8,7 @@ package ecdh
 
 import (
 	"crypto"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140/ecdh"
 	"crypto/subtle"
 	"errors"
diff --git a/src/crypto/ecdh/ecdh_test.go b/src/crypto/ecdh/ecdh_test.go
index 75d2480775669f..6a4d26fbafe090 100644
--- a/src/crypto/ecdh/ecdh_test.go
+++ b/src/crypto/ecdh/ecdh_test.go
@@ -9,6 +9,7 @@ import (
 	"crypto"
 	"crypto/cipher"
 	"crypto/ecdh"
+	boring "crypto/internal/backend"
 	"crypto/rand"
 	"crypto/sha256"
 	"encoding/hex"
@@ -280,6 +281,9 @@ var invalidPrivateKeys = map[ecdh.Curve][]string{
 }
 
 func TestNewPrivateKey(t *testing.T) {
+	if boring.Enabled {
+		t.Skip("skipping test with different results when using different backends")
+	}
 	testAllCurves(t, func(t *testing.T, curve ecdh.Curve) {
 		for _, input := range invalidPrivateKeys[curve] {
 			k, err := curve.NewPrivateKey(hexDecode(t, input))
diff --git a/src/crypto/ecdh/nist.go b/src/crypto/ecdh/nist.go
index acef8298943c2b..ca6171cf775117 100644
--- a/src/crypto/ecdh/nist.go
+++ b/src/crypto/ecdh/nist.go
@@ -6,7 +6,7 @@ package ecdh
 
 import (
 	"bytes"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140/ecdh"
 	"crypto/internal/fips140only"
 	"errors"
diff --git a/src/crypto/ecdsa/badlinkname.go b/src/crypto/ecdsa/badlinkname.go
new file mode 100644
index 00000000000000..1dc05d09b2062d
--- /dev/null
+++ b/src/crypto/ecdsa/badlinkname.go
@@ -0,0 +1,19 @@
+// Copyright 2025 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build goexperiment.systemcrypto
+
+package ecdsa
+
+import _ "unsafe"
+
+// The symbols below are pulled by some crypto backend in the Microsoft Go compiler.
+// We provide a push linkname here, to keep them accessible with pull linknames.
+
+//go:linkname encodeSignature
+//go:linkname parseSignature
+
+// This supplements other linknames that are already added by
+// https://github.com/golang/go/commit/41aab30bd260297ad8ddad47e98fdf8390a9a67e
+// See that commit for more information.
diff --git a/src/crypto/ecdsa/boring.go b/src/crypto/ecdsa/boring.go
index 275c60b4de49eb..ff8bddf28c4545 100644
--- a/src/crypto/ecdsa/boring.go
+++ b/src/crypto/ecdsa/boring.go
@@ -2,13 +2,13 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto
+//go:build goexperiment.systemcrypto
 
 package ecdsa
 
 import (
-	"crypto/internal/boring"
-	"crypto/internal/boring/bbig"
+	boring "crypto/internal/backend"
+	"crypto/internal/backend/bbig"
 	"crypto/internal/boring/bcache"
 	"math/big"
 )
diff --git a/src/crypto/ecdsa/ecdsa.go b/src/crypto/ecdsa/ecdsa.go
index cb308b41e9df86..7bfdc76759baeb 100644
--- a/src/crypto/ecdsa/ecdsa.go
+++ b/src/crypto/ecdsa/ecdsa.go
@@ -20,8 +20,8 @@ import (
 	"crypto"
 	"crypto/ecdh"
 	"crypto/elliptic"
-	"crypto/internal/boring"
-	"crypto/internal/boring/bbig"
+	boring "crypto/internal/backend"
+	"crypto/internal/backend/bbig"
 	"crypto/internal/fips140/ecdsa"
 	"crypto/internal/fips140hash"
 	"crypto/internal/fips140only"
@@ -162,7 +162,7 @@ func (priv *PrivateKey) Sign(rand io.Reader, digest []byte, opts crypto.SignerOp
 func GenerateKey(c elliptic.Curve, rand io.Reader) (*PrivateKey, error) {
 	randutil.MaybeReadByte(rand)
 
-	if boring.Enabled && rand == boring.RandReader {
+	if boring.Enabled && rand == boring.RandReader && boring.SupportsCurve(c.Params().Name) {
 		x, y, d, err := boring.GenerateKeyECDSA(c.Params().Name)
 		if err != nil {
 			return nil, err
@@ -211,7 +211,7 @@ var errNoAsm = errors.New("no assembly implementation available")
 func SignASN1(rand io.Reader, priv *PrivateKey, hash []byte) ([]byte, error) {
 	randutil.MaybeReadByte(rand)
 
-	if boring.Enabled && rand == boring.RandReader {
+	if boring.Enabled && rand == boring.RandReader && boring.SupportsCurve(priv.Curve.Params().Name) {
 		b, err := boringPrivateKey(priv)
 		if err != nil {
 			return nil, err
@@ -326,7 +326,7 @@ func addASN1IntBytes(b *cryptobyte.Builder, bytes []byte) {
 // The inputs are not considered confidential, and may leak through timing side
 // channels, or if an attacker has control of part of the inputs.
 func VerifyASN1(pub *PublicKey, hash, sig []byte) bool {
-	if boring.Enabled {
+	if boring.Enabled && boring.SupportsCurve(pub.Curve.Params().Name) {
 		key, err := boringPublicKey(pub)
 		if err != nil {
 			return false
diff --git a/src/crypto/ecdsa/notboring.go b/src/crypto/ecdsa/notboring.go
index 039bd82ed21f9f..69a97d9bf250be 100644
--- a/src/crypto/ecdsa/notboring.go
+++ b/src/crypto/ecdsa/notboring.go
@@ -2,11 +2,11 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build !boringcrypto
+//go:build !goexperiment.systemcrypto
 
 package ecdsa
 
-import "crypto/internal/boring"
+import boring "crypto/internal/backend"
 
 func boringPublicKey(*PublicKey) (*boring.PublicKeyECDSA, error) {
 	panic("boringcrypto: not available")
diff --git a/src/crypto/ed25519/boring.go b/src/crypto/ed25519/boring.go
new file mode 100644
index 00000000000000..4e18cdfbaad4fd
--- /dev/null
+++ b/src/crypto/ed25519/boring.go
@@ -0,0 +1,71 @@
+// Copyright 2023 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build goexperiment.systemcrypto
+
+package ed25519
+
+import (
+	boring "crypto/internal/backend"
+	"crypto/internal/boring/bcache"
+	"unsafe"
+)
+
+var pubCache bcache.Cache[byte, boringPub]
+var privCache bcache.Cache[byte, boringPriv]
+
+func init() {
+	if boring.Enabled && boring.SupportsEd25519() {
+		pubCache.Register()
+		privCache.Register()
+	}
+}
+
+type boringPub struct {
+	key  boring.PublicKeyEd25519
+	orig [PublicKeySize]byte
+}
+
+func boringPublicKey(pub PublicKey) (boring.PublicKeyEd25519, error) {
+	// Use the pointer to the underlying pub array as key.
+	p := unsafe.SliceData(pub)
+	b := pubCache.Get(p)
+	if b != nil && PublicKey(b.orig[:]).Equal(pub) {
+		return b.key, nil
+	}
+
+	b = new(boringPub)
+	copy(b.orig[:], pub)
+	key, err := boring.NewPublicKeyEd25519(b.orig[:])
+	if err != nil {
+		return key, err
+	}
+	b.key = key
+	pubCache.Put(p, b)
+	return key, nil
+}
+
+type boringPriv struct {
+	key  boring.PrivateKeyEd25519
+	orig [PrivateKeySize]byte
+}
+
+func boringPrivateKey(priv PrivateKey) (boring.PrivateKeyEd25519, error) {
+	// Use the pointer to the underlying priv array as key.
+	p := unsafe.SliceData(priv)
+	b := privCache.Get(p)
+	if b != nil && PrivateKey(b.orig[:]).Equal(priv) {
+		return b.key, nil
+	}
+
+	b = new(boringPriv)
+	copy(b.orig[:], priv)
+	key, err := boring.NewPrivateKeyEd25519(b.orig[:])
+	if err != nil {
+		return key, err
+	}
+	b.key = key
+	privCache.Put(p, b)
+	return key, nil
+}
diff --git a/src/crypto/ed25519/ed25519.go b/src/crypto/ed25519/ed25519.go
index c1f8ff784e4a5c..6476bfbe896d6c 100644
--- a/src/crypto/ed25519/ed25519.go
+++ b/src/crypto/ed25519/ed25519.go
@@ -17,6 +17,7 @@ package ed25519
 
 import (
 	"crypto"
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140/ed25519"
 	"crypto/internal/fips140only"
 	cryptorand "crypto/rand"
@@ -24,6 +25,7 @@ import (
 	"errors"
 	"io"
 	"strconv"
+	"sync"
 )
 
 const (
@@ -138,6 +140,22 @@ func GenerateKey(rand io.Reader) (PublicKey, PrivateKey, error) {
 	if rand == nil {
 		rand = cryptorand.Reader
 	}
+	if boring.Enabled && boring.SupportsEd25519() {
+		if rand == boring.RandReader {
+			priv, err := boring.GenerateKeyEd25519()
+			if err != nil {
+				return nil, nil, err
+			}
+			privData, err := priv.Bytes()
+			if err != nil {
+				return nil, nil, err
+			}
+			privKey := PrivateKey(privData)
+			pubKey := privKey.Public().(PublicKey)
+			return pubKey, privKey, err
+		}
+		boring.UnreachableExceptTests()
+	}
 
 	seed := make([]byte, SeedSize)
 	if _, err := io.ReadFull(rand, seed); err != nil {
@@ -154,6 +172,17 @@ func GenerateKey(rand io.Reader) (PublicKey, PrivateKey, error) {
 // with RFC 8032. RFC 8032's private keys correspond to seeds in this
 // package.
 func NewKeyFromSeed(seed []byte) PrivateKey {
+	if boring.Enabled && boring.SupportsEd25519() {
+		key, err := boring.NewPrivateKeyEd25519FromSeed(seed)
+		if err != nil {
+			panic(err)
+		}
+		d, err := key.Bytes()
+		if err != nil {
+			panic(err)
+		}
+		return PrivateKey(d)
+	}
 	// Outline the function body so that the returned key can be stack-allocated.
 	privateKey := make([]byte, PrivateKeySize)
 	newKeyFromSeed(privateKey, seed)
@@ -172,6 +201,17 @@ func newKeyFromSeed(privateKey, seed []byte) {
 // Sign signs the message with privateKey and returns a signature. It will
 // panic if len(privateKey) is not [PrivateKeySize].
 func Sign(privateKey PrivateKey, message []byte) []byte {
+	if boring.Enabled && boring.SupportsEd25519() {
+		priv, err := boringPrivateKey(privateKey)
+		if err != nil {
+			panic(err)
+		}
+		signature, err := boring.SignEd25519(priv, message)
+		if err != nil {
+			panic(err)
+		}
+		return signature
+	}
 	// Outline the function body so that the returned signature can be
 	// stack-allocated.
 	signature := make([]byte, SignatureSize)
@@ -200,6 +240,32 @@ func Verify(publicKey PublicKey, message, sig []byte) bool {
 	return VerifyWithOptions(publicKey, message, sig, &Options{Hash: crypto.Hash(0)}) == nil
 }
 
+// testMalleability returns true if the crypto backend correctly rejects
+// malleable signatures. The only known backend that fails to do so is
+// OpenSSL version 1.1.1a or lower.
+// See https://github.com/openssl/openssl/issues/7693.
+var testMalleability = sync.OnceValue(func() bool {
+	msg := []byte{0x54, 0x65, 0x73, 0x74}
+	sig := []byte{
+		0x7c, 0x38, 0xe0, 0x26, 0xf2, 0x9e, 0x14, 0xaa, 0xbd, 0x05, 0x9a,
+		0x0f, 0x2d, 0xb8, 0xb0, 0xcd, 0x78, 0x30, 0x40, 0x60, 0x9a, 0x8b,
+		0xe6, 0x84, 0xdb, 0x12, 0xf8, 0x2a, 0x27, 0x77, 0x4a, 0xb0, 0x67,
+		0x65, 0x4b, 0xce, 0x38, 0x32, 0xc2, 0xd7, 0x6f, 0x8f, 0x6f, 0x5d,
+		0xaf, 0xc0, 0x8d, 0x93, 0x39, 0xd4, 0xee, 0xf6, 0x76, 0x57, 0x33,
+		0x36, 0xa5, 0xc5, 0x1e, 0xb6, 0xf9, 0x46, 0xb3, 0x1d,
+	}
+	pkey := []byte{
+		0x7d, 0x4d, 0x0e, 0x7f, 0x61, 0x53, 0xa6, 0x9b, 0x62, 0x42, 0xb5,
+		0x22, 0xab, 0xbe, 0xe6, 0x85, 0xfd, 0xa4, 0x42, 0x0f, 0x88, 0x34,
+		0xb1, 0x08, 0xc3, 0xbd, 0xae, 0x36, 0x9e, 0xf5, 0x49, 0xfa,
+	}
+	pub, err := boring.NewPublicKeyEd25519(pkey)
+	if err != nil {
+		return false
+	}
+	return boring.VerifyEd25519(pub, msg, sig) != nil
+})
+
 // VerifyWithOptions reports whether sig is a valid signature of message by
 // publicKey. A valid signature is indicated by returning a nil error. It will
 // panic if len(publicKey) is not [PublicKeySize].
@@ -228,6 +294,13 @@ func VerifyWithOptions(publicKey PublicKey, message, sig []byte, opts *Options)
 		}
 		return ed25519.VerifyCtx(k, message, sig, opts.Context)
 	case opts.Hash == crypto.Hash(0): // Ed25519
+		if boring.Enabled && boring.SupportsEd25519() && testMalleability() {
+			pub, err := boringPublicKey(publicKey)
+			if err != nil {
+				return err
+			}
+			return boring.VerifyEd25519(pub, message, sig)
+		}
 		return ed25519.Verify(k, message, sig)
 	default:
 		return errors.New("ed25519: expected opts.Hash zero (unhashed message, for standard Ed25519) or SHA-512 (for Ed25519ph)")
diff --git a/src/crypto/ed25519/ed25519_test.go b/src/crypto/ed25519/ed25519_test.go
index 87d0132df11d8b..00dd5224a70418 100644
--- a/src/crypto/ed25519/ed25519_test.go
+++ b/src/crypto/ed25519/ed25519_test.go
@@ -13,6 +13,7 @@ import (
 	"crypto/rand"
 	"crypto/sha512"
 	"encoding/hex"
+	"internal/goexperiment"
 	"log"
 	"os"
 	"strings"
@@ -316,7 +317,7 @@ func TestGolden(t *testing.T) {
 		copy(priv[32:], pubKey)
 
 		sig2 := Sign(priv[:], msg)
-		if !bytes.Equal(sig, sig2[:]) {
+		if !bytes.Equal(sig, sig2[:]) && !goexperiment.DarwinCrypto {
 			t.Errorf("different signature result on line %d: %x vs %x", lineNo, sig, sig2)
 		}
 
diff --git a/src/crypto/ed25519/notboring.go b/src/crypto/ed25519/notboring.go
new file mode 100644
index 00000000000000..77b69a3be88183
--- /dev/null
+++ b/src/crypto/ed25519/notboring.go
@@ -0,0 +1,16 @@
+// Copyright 2023 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build !goexperiment.systemcrypto
+
+package ed25519
+
+import boring "crypto/internal/backend"
+
+func boringPublicKey(PublicKey) (boring.PublicKeyEd25519, error) {
+	panic("boringcrypto: not available")
+}
+func boringPrivateKey(PrivateKey) (boring.PrivateKeyEd25519, error) {
+	panic("boringcrypto: not available")
+}
diff --git a/src/crypto/fips140/fips140.go b/src/crypto/fips140/fips140.go
index 41d0d170cf9fc8..b6b413532d8104 100644
--- a/src/crypto/fips140/fips140.go
+++ b/src/crypto/fips140/fips140.go
@@ -5,6 +5,7 @@
 package fips140
 
 import (
+	bfips140 "crypto/internal/backend/fips140"
 	"crypto/internal/fips140"
 	"crypto/internal/fips140/check"
 	"internal/godebug"
@@ -29,5 +30,5 @@ func Enabled() bool {
 	if fips140.Enabled && !check.Verified {
 		panic("crypto/fips140: FIPS 140-3 mode enabled, but integrity check didn't pass")
 	}
-	return fips140.Enabled
+	return fips140.Enabled || bfips140.Enabled()
 }
diff --git a/src/crypto/hkdf/hkdf.go b/src/crypto/hkdf/hkdf.go
index 6b02522866d57f..37e67ec184af5d 100644
--- a/src/crypto/hkdf/hkdf.go
+++ b/src/crypto/hkdf/hkdf.go
@@ -11,6 +11,7 @@
 package hkdf
 
 import (
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140/hkdf"
 	"crypto/internal/fips140hash"
 	"crypto/internal/fips140only"
@@ -29,6 +30,9 @@ func Extract[H hash.Hash](h func() H, secret, salt []byte) ([]byte, error) {
 	if err := checkFIPS140Only(fh, secret); err != nil {
 		return nil, err
 	}
+	if boring.Enabled && boring.SupportsHKDF() {
+		return boring.ExtractHKDF(fh, secret, salt)
+	}
 	return hkdf.Extract(fh, secret, salt), nil
 }
 
@@ -50,6 +54,9 @@ func Expand[H hash.Hash](h func() H, pseudorandomKey []byte, info string, keyLen
 		return nil, errors.New("hkdf: requested key length too large")
 	}
 
+	if boring.Enabled && boring.SupportsHKDF() {
+		return boring.ExpandHKDF(fh, pseudorandomKey, []byte(info), keyLength)
+	}
 	return hkdf.Expand(fh, pseudorandomKey, info, keyLength), nil
 }
 
@@ -67,6 +74,13 @@ func Key[Hash hash.Hash](h func() Hash, secret, salt []byte, info string, keyLen
 		return nil, errors.New("hkdf: requested key length too large")
 	}
 
+	if boring.Enabled && boring.SupportsHKDF() {
+		pseudorandomKey, err := boring.ExtractHKDF(fh, secret, salt)
+		if err != nil {
+			return nil, err
+		}
+		return boring.ExpandHKDF(fh, pseudorandomKey, []byte(info), keyLength)
+	}
 	return hkdf.Key(fh, secret, salt, info, keyLength), nil
 }
 
diff --git a/src/crypto/hkdf/hkdf_test.go b/src/crypto/hkdf/hkdf_test.go
index 201b440289bb2d..4ed4960ff35b66 100644
--- a/src/crypto/hkdf/hkdf_test.go
+++ b/src/crypto/hkdf/hkdf_test.go
@@ -6,7 +6,7 @@ package hkdf
 
 import (
 	"bytes"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140"
 	"crypto/md5"
 	"crypto/sha1"
diff --git a/src/crypto/hmac/hmac.go b/src/crypto/hmac/hmac.go
index 554c8c9b78940b..c68a394280cc2c 100644
--- a/src/crypto/hmac/hmac.go
+++ b/src/crypto/hmac/hmac.go
@@ -22,7 +22,7 @@ timing side-channels:
 package hmac
 
 import (
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140/hmac"
 	"crypto/internal/fips140hash"
 	"crypto/internal/fips140only"
diff --git a/src/crypto/hmac/hmac_test.go b/src/crypto/hmac/hmac_test.go
index 7accad763244a1..dd3211f2c37af3 100644
--- a/src/crypto/hmac/hmac_test.go
+++ b/src/crypto/hmac/hmac_test.go
@@ -5,7 +5,7 @@
 package hmac
 
 import (
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/cryptotest"
 	"crypto/md5"
 	"crypto/sha1"
diff --git a/src/crypto/internal/cryptotest/allocations.go b/src/crypto/internal/cryptotest/allocations.go
index 70055af70b42ec..3c4b4fbaa98ded 100644
--- a/src/crypto/internal/cryptotest/allocations.go
+++ b/src/crypto/internal/cryptotest/allocations.go
@@ -5,7 +5,7 @@
 package cryptotest
 
 import (
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"internal/asan"
 	"internal/msan"
 	"internal/race"
diff --git a/src/crypto/internal/cryptotest/implementations.go b/src/crypto/internal/cryptotest/implementations.go
index 3fa730459050f6..1f28f12a6e7b4f 100644
--- a/src/crypto/internal/cryptotest/implementations.go
+++ b/src/crypto/internal/cryptotest/implementations.go
@@ -5,7 +5,7 @@
 package cryptotest
 
 import (
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/impl"
 	"internal/goos"
 	"internal/testenv"
diff --git a/src/crypto/internal/fips140test/check_test.go b/src/crypto/internal/fips140test/check_test.go
index 6b0cd3f39e1695..237cf289dd45cf 100644
--- a/src/crypto/internal/fips140test/check_test.go
+++ b/src/crypto/internal/fips140test/check_test.go
@@ -5,6 +5,7 @@
 package fipstest
 
 import (
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140"
 	. "crypto/internal/fips140/check"
 	"crypto/internal/fips140/check/checktest"
@@ -18,7 +19,7 @@ import (
 	"unsafe"
 )
 
-const enableFIPSTest = true
+const enableFIPSTest = boring.Enabled
 
 func TestFIPSCheckVerify(t *testing.T) {
 	if Verified {
diff --git a/src/crypto/md5/md5.go b/src/crypto/md5/md5.go
index a0384e175f31bd..f7aa6da36f02de 100644
--- a/src/crypto/md5/md5.go
+++ b/src/crypto/md5/md5.go
@@ -12,6 +12,7 @@ package md5
 
 import (
 	"crypto"
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140only"
 	"errors"
 	"hash"
@@ -104,6 +105,9 @@ func consumeUint32(b []byte) ([]byte, uint32) {
 // [encoding.BinaryUnmarshaler] to marshal and unmarshal the internal
 // state of the hash.
 func New() hash.Hash {
+	if boring.Enabled && boring.SupportsHash(crypto.MD5) {
+		return boring.NewMD5()
+	}
 	d := new(digest)
 	d.Reset()
 	return d
@@ -188,6 +192,12 @@ func (d *digest) checkSum() [Size]byte {
 
 // Sum returns the MD5 checksum of the data.
 func Sum(data []byte) [Size]byte {
+	if boring.Enabled && boring.SupportsHash(crypto.MD5) {
+		if fips140only.Enabled {
+			panic("crypto/md5: use of MD5 is not allowed in FIPS 140-only mode")
+		}
+		return boring.MD5(data)
+	}
 	var d digest
 	d.Reset()
 	d.Write(data)
diff --git a/src/crypto/md5/md5_test.go b/src/crypto/md5/md5_test.go
index 437d9b9d4c0e0d..50728df60ea7ec 100644
--- a/src/crypto/md5/md5_test.go
+++ b/src/crypto/md5/md5_test.go
@@ -6,12 +6,14 @@ package md5
 
 import (
 	"bytes"
+	boring "crypto/internal/backend"
 	"crypto/internal/cryptotest"
 	"crypto/rand"
 	"encoding"
 	"fmt"
 	"hash"
 	"io"
+	"strings"
 	"testing"
 	"unsafe"
 )
@@ -96,6 +98,9 @@ func TestGoldenMarshal(t *testing.T) {
 
 		state, err := h.(encoding.BinaryMarshaler).MarshalBinary()
 		if err != nil {
+			if strings.Contains(err.Error(), "hash state is not marshallable") {
+				t.Skip("BinaryMarshaler not supported")
+			}
 			t.Errorf("could not marshal: %v", err)
 			continue
 		}
@@ -157,6 +162,9 @@ func TestLarge(t *testing.T) {
 
 // Tests that blockGeneric (pure Go) and block (in assembly for amd64, 386, arm) match.
 func TestBlockGeneric(t *testing.T) {
+	if boring.Enabled {
+		t.Skip("digest is not used when boring.Enabled is set")
+	}
 	gen, asm := New().(*digest), New().(*digest)
 	buf := make([]byte, BlockSize*20) // arbitrary factor
 	rand.Read(buf)
@@ -204,10 +212,18 @@ func safeSum(h hash.Hash) (sum []byte, err error) {
 }
 
 func TestLargeHashes(t *testing.T) {
+	if boring.Enabled {
+		if _, ok := New().(encoding.BinaryUnmarshaler); !ok {
+			t.Skip("BinaryUnmarshaler not implemented")
+		}
+	}
 	for i, test := range largeUnmarshalTests {
 
 		h := New()
 		if err := h.(encoding.BinaryUnmarshaler).UnmarshalBinary([]byte(test.state)); err != nil {
+			if strings.Contains(err.Error(), "hash state is not marshallable") {
+				t.Skip("BinaryMarshaler not supported")
+			}
 			t.Errorf("test %d could not unmarshal: %v", i, err)
 			continue
 		}
diff --git a/src/crypto/pbkdf2/pbkdf2.go b/src/crypto/pbkdf2/pbkdf2.go
index 271d2b03312ef0..ff76299fbe4782 100644
--- a/src/crypto/pbkdf2/pbkdf2.go
+++ b/src/crypto/pbkdf2/pbkdf2.go
@@ -11,6 +11,7 @@
 package pbkdf2
 
 import (
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140/pbkdf2"
 	"crypto/internal/fips140hash"
 	"crypto/internal/fips140only"
@@ -47,5 +48,8 @@ func Key[Hash hash.Hash](h func() Hash, password string, salt []byte, iter, keyL
 			return nil, errors.New("crypto/pbkdf2: use of hash functions other than SHA-2 or SHA-3 is not allowed in FIPS 140-only mode")
 		}
 	}
+	if boring.Enabled && boring.SupportsPBKDF2() {
+		return boring.PBKDF2([]byte(password), salt, iter, keyLength, fh)
+	}
 	return pbkdf2.Key(fh, password, salt, iter, keyLength)
 }
diff --git a/src/crypto/pbkdf2/pbkdf2_test.go b/src/crypto/pbkdf2/pbkdf2_test.go
index 03980c7e54d3be..4968a666fad4e5 100644
--- a/src/crypto/pbkdf2/pbkdf2_test.go
+++ b/src/crypto/pbkdf2/pbkdf2_test.go
@@ -6,7 +6,7 @@ package pbkdf2_test
 
 import (
 	"bytes"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140"
 	"crypto/pbkdf2"
 	"crypto/sha1"
diff --git a/src/crypto/purego_test.go b/src/crypto/purego_test.go
index 62be347e0c6822..d284b5cf7814a6 100644
--- a/src/crypto/purego_test.go
+++ b/src/crypto/purego_test.go
@@ -41,7 +41,7 @@ func TestPureGoTag(t *testing.T) {
 	}
 
 	for _, pkgName := range pkgs {
-		if strings.Contains(pkgName, "/boring") {
+		if strings.Contains(pkgName, "/boring") || strings.Contains(pkgName, "/internal/backend") || strings.Contains(pkgName, "tls/fipsonly") {
 			continue
 		}
 
diff --git a/src/crypto/rand/rand.go b/src/crypto/rand/rand.go
index 1ca16caa9563e6..3ef22b5ff8222b 100644
--- a/src/crypto/rand/rand.go
+++ b/src/crypto/rand/rand.go
@@ -7,7 +7,7 @@
 package rand
 
 import (
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140"
 	"crypto/internal/fips140/drbg"
 	"crypto/internal/sysrand"
diff --git a/src/crypto/rc4/rc4.go b/src/crypto/rc4/rc4.go
index 90943a0935befb..09ebdfd733e5d6 100644
--- a/src/crypto/rc4/rc4.go
+++ b/src/crypto/rc4/rc4.go
@@ -10,6 +10,7 @@
 package rc4
 
 import (
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140/alias"
 	"crypto/internal/fips140only"
 	"errors"
@@ -20,6 +21,8 @@ import (
 type Cipher struct {
 	s    [256]uint32
 	i, j uint8
+
+	boring *boring.RC4Cipher
 }
 
 type KeySizeError int
@@ -38,6 +41,13 @@ func NewCipher(key []byte) (*Cipher, error) {
 	if k < 1 || k > 256 {
 		return nil, KeySizeError(k)
 	}
+	if boring.Enabled && boring.SupportsRC4() {
+		c, err := boring.NewRC4Cipher(key)
+		if err != nil {
+			return nil, err
+		}
+		return &Cipher{boring: c}, nil
+	}
 	var c Cipher
 	for i := 0; i < 256; i++ {
 		c.s[i] = uint32(i)
@@ -55,6 +65,10 @@ func NewCipher(key []byte) (*Cipher, error) {
 // Deprecated: Reset can't guarantee that the key will be entirely removed from
 // the process's memory.
 func (c *Cipher) Reset() {
+	if boring.Enabled && boring.SupportsRC4() {
+		c.boring.Reset()
+		return
+	}
 	for i := range c.s {
 		c.s[i] = 0
 	}
@@ -64,6 +78,10 @@ func (c *Cipher) Reset() {
 // XORKeyStream sets dst to the result of XORing src with the key stream.
 // Dst and src must overlap entirely or not at all.
 func (c *Cipher) XORKeyStream(dst, src []byte) {
+	if boring.Enabled && boring.SupportsRC4() {
+		c.boring.XORKeyStream(dst, src)
+		return
+	}
 	if len(src) == 0 {
 		return
 	}
diff --git a/src/crypto/rsa/boring.go b/src/crypto/rsa/boring.go
index b9f9d3154f2589..ba66dd33a1f9f3 100644
--- a/src/crypto/rsa/boring.go
+++ b/src/crypto/rsa/boring.go
@@ -2,14 +2,15 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto
+//go:build goexperiment.systemcrypto
 
 package rsa
 
 import (
-	"crypto/internal/boring"
-	"crypto/internal/boring/bbig"
+	boring "crypto/internal/backend"
+	"crypto/internal/backend/bbig"
 	"crypto/internal/boring/bcache"
+	"internal/goexperiment"
 	"math/big"
 )
 
@@ -62,6 +63,11 @@ type boringPriv struct {
 }
 
 func boringPrivateKey(priv *PrivateKey) (*boring.PrivateKeyRSA, error) {
+	// CommonCrypto requires the CRT values to be precomputed if nil
+	if goexperiment.DarwinCrypto && (priv.Precomputed.Dp == nil || priv.Precomputed.Dq == nil || priv.Precomputed.Qinv == nil) {
+		priv.Precompute()
+		priv.Precomputed.fips = nil
+	}
 	b := privCache.Get(priv)
 	if b != nil && privateKeyEqual(&b.orig, priv) {
 		return b.key, nil
diff --git a/src/crypto/rsa/boring_test.go b/src/crypto/rsa/boring_test.go
index 838fcc1244bdbe..d89f732345e8a3 100644
--- a/src/crypto/rsa/boring_test.go
+++ b/src/crypto/rsa/boring_test.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto
+//go:build goexperiment.systemcrypto
 
 // Note: Can run these tests against the non-BoringCrypto
 // version of the code by using "CGO_ENABLED=0 go test".
diff --git a/src/crypto/rsa/darwin.go b/src/crypto/rsa/darwin.go
new file mode 100644
index 00000000000000..1b9c63523ee90e
--- /dev/null
+++ b/src/crypto/rsa/darwin.go
@@ -0,0 +1,71 @@
+// Copyright 2017 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build goexperiment.darwincrypto
+
+package rsa
+
+import (
+	"crypto/internal/backend"
+	"crypto/internal/backend/bbig"
+	"errors"
+	"math/big"
+	_ "unsafe"
+
+	"golang.org/x/crypto/cryptobyte"
+	"golang.org/x/crypto/cryptobyte/asn1"
+)
+
+//go:linkname decodeKey
+func decodeKey(data []byte) (N, E, D, P, Q, Dp, Dq, Qinv backend.BigInt, err error) {
+	bad := func(e error) (N, E, D, P, Q, Dp, Dq, Qinv backend.BigInt, err error) {
+		return nil, nil, nil, nil, nil, nil, nil, nil, e
+	}
+	input := cryptobyte.String(data)
+	var version int
+	n, e, d, p, q, dp, dq, qinv := new(big.Int), new(big.Int), new(big.Int), new(big.Int),
+		new(big.Int), new(big.Int), new(big.Int), new(big.Int)
+	// Parse the ASN.1 sequence
+	if !input.ReadASN1(&input, asn1.SEQUENCE) {
+		return bad(errors.New("invalid ASN.1 structure: not a sequence"))
+	}
+	if !input.ReadASN1Integer(&version) || version != 0 {
+		return bad(errors.New("invalid ASN.1 structure: unsupported version"))
+	}
+	if !input.ReadASN1Integer(n) || !input.ReadASN1Integer(e) ||
+		!input.ReadASN1Integer(d) || !input.ReadASN1Integer(p) ||
+		!input.ReadASN1Integer(q) || !input.ReadASN1Integer(dp) ||
+		!input.ReadASN1Integer(dq) || !input.ReadASN1Integer(qinv) {
+		return bad(errors.New("invalid ASN.1 structure"))
+	}
+	return bbig.Enc(n), bbig.Enc(e), bbig.Enc(d), bbig.Enc(p), bbig.Enc(q),
+		bbig.Enc(dp), bbig.Enc(dq), bbig.Enc(qinv), nil
+}
+
+//go:linkname encodeKey
+func encodeKey(N, E, D, P, Q, Dp, Dq, Qinv backend.BigInt) ([]byte, error) {
+	builder := cryptobyte.NewBuilder(nil)
+	builder.AddASN1(asn1.SEQUENCE, func(b *cryptobyte.Builder) {
+		b.AddASN1Int64(0)               // Add version as int64
+		b.AddASN1BigInt(bbig.Dec(N))    // Add modulus
+		b.AddASN1BigInt(bbig.Dec(E))    // Add public exponent
+		b.AddASN1BigInt(bbig.Dec(D))    // Add private exponent
+		b.AddASN1BigInt(bbig.Dec(P))    // Add prime1
+		b.AddASN1BigInt(bbig.Dec(Q))    // Add prime2
+		b.AddASN1BigInt(bbig.Dec(Dp))   // Add exponent1
+		b.AddASN1BigInt(bbig.Dec(Dq))   // Add exponent2
+		b.AddASN1BigInt(bbig.Dec(Qinv)) // Add coefficient
+	})
+	return builder.Bytes()
+}
+
+//go:linkname encodePublicKey
+func encodePublicKey(N, E backend.BigInt) ([]byte, error) {
+	builder := cryptobyte.NewBuilder(nil)
+	builder.AddASN1(asn1.SEQUENCE, func(b *cryptobyte.Builder) {
+		b.AddASN1BigInt(bbig.Dec(N)) // Add modulus
+		b.AddASN1BigInt(bbig.Dec(E)) // Add public exponent
+	})
+	return builder.Bytes()
+}
diff --git a/src/crypto/rsa/fips.go b/src/crypto/rsa/fips.go
index 8373c125ae3096..990ea980faf33f 100644
--- a/src/crypto/rsa/fips.go
+++ b/src/crypto/rsa/fips.go
@@ -6,7 +6,7 @@ package rsa
 
 import (
 	"crypto"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140/rsa"
 	"crypto/internal/fips140hash"
 	"crypto/internal/fips140only"
@@ -70,7 +70,7 @@ func SignPSS(rand io.Reader, priv *PrivateKey, hash crypto.Hash, digest []byte,
 		hash = opts.Hash
 	}
 
-	if boring.Enabled && rand == boring.RandReader {
+	if boring.Enabled && rand == boring.RandReader && boring.SupportsRSASaltLength(true, opts.saltLength()) && boring.SupportsRSAKeyPrimes(len(priv.Primes)) && boring.SupportsHash(hash) {
 		bkey, err := boringPrivateKey(priv)
 		if err != nil {
 			return nil, err
@@ -133,7 +133,7 @@ func VerifyPSS(pub *PublicKey, hash crypto.Hash, digest []byte, sig []byte, opts
 		return err
 	}
 
-	if boring.Enabled {
+	if boring.Enabled && boring.SupportsRSASaltLength(false, opts.saltLength()) && boring.SupportsHash(hash) {
 		bkey, err := boringPublicKey(pub)
 		if err != nil {
 			return err
@@ -197,7 +197,7 @@ func EncryptOAEP(hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, l
 
 	defer hash.Reset()
 
-	if boring.Enabled && random == boring.RandReader {
+	if boring.Enabled && random == boring.RandReader && boring.SupportsRSAOAEPLabel(label) {
 		hash.Reset()
 		k := pub.Size()
 		if len(msg) > k-2*hash.Size()-2 {
@@ -250,7 +250,7 @@ func decryptOAEP(hash, mgfHash hash.Hash, priv *PrivateKey, ciphertext []byte, l
 		return nil, err
 	}
 
-	if boring.Enabled {
+	if boring.Enabled && boring.SupportsRSAKeyPrimes(len(priv.Primes)) && boring.SupportsRSAOAEPLabel(label) {
 		k := priv.Size()
 		if len(ciphertext) > k ||
 			k < hash.Size()*2+2 {
@@ -312,7 +312,7 @@ func SignPKCS1v15(random io.Reader, priv *PrivateKey, hash crypto.Hash, hashed [
 		return nil, err
 	}
 
-	if boring.Enabled {
+	if boring.Enabled && boring.SupportsRSAKeyPrimes(len(priv.Primes)) && boring.SupportsPKCS1v15Hash(hash) {
 		bkey, err := boringPrivateKey(priv)
 		if err != nil {
 			return nil, err
@@ -355,7 +355,7 @@ func VerifyPKCS1v15(pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte)
 		return err
 	}
 
-	if boring.Enabled {
+	if boring.Enabled && boring.SupportsPKCS1v15Hash(hash) {
 		bkey, err := boringPublicKey(pub)
 		if err != nil {
 			return err
diff --git a/src/crypto/rsa/notboring.go b/src/crypto/rsa/notboring.go
index 2abc0436405f8a..3e4d6f3eef61e6 100644
--- a/src/crypto/rsa/notboring.go
+++ b/src/crypto/rsa/notboring.go
@@ -2,11 +2,11 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build !boringcrypto
+//go:build !goexperiment.systemcrypto
 
 package rsa
 
-import "crypto/internal/boring"
+import boring "crypto/internal/backend"
 
 func boringPublicKey(*PublicKey) (*boring.PublicKeyRSA, error) {
 	panic("boringcrypto: not available")
diff --git a/src/crypto/rsa/pkcs1v15.go b/src/crypto/rsa/pkcs1v15.go
index f1e4ef48a4fd1c..a179a4388e3ee5 100644
--- a/src/crypto/rsa/pkcs1v15.go
+++ b/src/crypto/rsa/pkcs1v15.go
@@ -5,7 +5,7 @@
 package rsa
 
 import (
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140/rsa"
 	"crypto/internal/fips140only"
 	"crypto/internal/randutil"
@@ -104,7 +104,7 @@ func DecryptPKCS1v15(random io.Reader, priv *PrivateKey, ciphertext []byte) ([]b
 		return nil, err
 	}
 
-	if boring.Enabled {
+	if boring.Enabled && boring.SupportsRSAKeyPrimes(len(priv.Primes)) {
 		bkey, err := boringPrivateKey(priv)
 		if err != nil {
 			return nil, err
@@ -203,7 +203,7 @@ func decryptPKCS1v15(priv *PrivateKey, ciphertext []byte) (valid int, em []byte,
 		return 0, nil, 0, err
 	}
 
-	if boring.Enabled {
+	if boring.Enabled && boring.SupportsRSAKeyPrimes(len(priv.Primes)) {
 		var bkey *boring.PrivateKeyRSA
 		bkey, err = boringPrivateKey(priv)
 		if err != nil {
diff --git a/src/crypto/rsa/pkcs1v15_test.go b/src/crypto/rsa/pkcs1v15_test.go
index c65552cd93526a..910416abe842f5 100644
--- a/src/crypto/rsa/pkcs1v15_test.go
+++ b/src/crypto/rsa/pkcs1v15_test.go
@@ -7,6 +7,7 @@ package rsa_test
 import (
 	"bytes"
 	"crypto"
+	boring "crypto/internal/backend"
 	"crypto/rand"
 	. "crypto/rsa"
 	"crypto/sha1"
@@ -235,6 +236,10 @@ func TestVerifyPKCS1v15(t *testing.T) {
 }
 
 func TestOverlongMessagePKCS1v15(t *testing.T) {
+	if boring.Enabled {
+		// See for example https://github.com/golang-fips/openssl/pull/142.
+		t.Skip("Some backends do not return an error for overlong messages.")
+	}
 	t.Setenv("GODEBUG", "rsa1024min=0")
 	ciphertext := decodeBase64("fjOVdirUzFoLlukv80dBllMLjXythIf22feqPrNo0YoIjzyzyoMFiLjAc/Y4krkeZ11XFThIrEvw\nkRiZcCq5ng==")
 	_, err := DecryptPKCS1v15(nil, test512Key, ciphertext)
diff --git a/src/crypto/rsa/pss_test.go b/src/crypto/rsa/pss_test.go
index e03f4ab06603c6..cd44f3af23b0d4 100644
--- a/src/crypto/rsa/pss_test.go
+++ b/src/crypto/rsa/pss_test.go
@@ -8,12 +8,14 @@ import (
 	"bufio"
 	"compress/bzip2"
 	"crypto"
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140"
 	"crypto/rand"
 	. "crypto/rsa"
 	"crypto/sha256"
 	"crypto/sha512"
 	"encoding/hex"
+	"internal/goexperiment"
 	"math/big"
 	"os"
 	"strconv"
@@ -104,6 +106,9 @@ func TestPSSGolden(t *testing.T) {
 			hashed = h.Sum(hashed[:0])
 
 			if err := VerifyPSS(key, hash, hashed, sig, opts); err != nil {
+				if goexperiment.DarwinCrypto && key.N.BitLen() == 1025 {
+					t.Skip("CommonCrypto doesn't support golden test entries with this key size")
+				}
 				t.Error(err)
 			}
 		default:
@@ -180,6 +185,10 @@ func TestPSSSigning(t *testing.T) {
 			continue
 		}
 
+		if boring.Enabled && test.good != test.fipsGood {
+			t.Skip("skipping test with different results when using different backends")
+		}
+
 		opts.SaltLength = test.verifySaltLength
 		err = VerifyPSS(&rsaPrivateKey.PublicKey, hash, hashed, sig, &opts)
 		good := test.good
@@ -241,7 +250,9 @@ func fromHex(hexStr string) []byte {
 
 func TestInvalidPSSSaltLength(t *testing.T) {
 	t.Setenv("GODEBUG", "rsa1024min=0")
-	key, err := GenerateKey(rand.Reader, 245)
+	// Most crypto backends don't support generating RSA keys with a bit size
+	// lower than 512, so we use 512 here.
+	key, err := GenerateKey(rand.Reader, 512)
 	if err != nil {
 		t.Fatal(err)
 	}
diff --git a/src/crypto/rsa/rsa.go b/src/crypto/rsa/rsa.go
index 95bb4becd2ff8c..73991434dabaf1 100644
--- a/src/crypto/rsa/rsa.go
+++ b/src/crypto/rsa/rsa.go
@@ -42,8 +42,8 @@ package rsa
 
 import (
 	"crypto"
-	"crypto/internal/boring"
-	"crypto/internal/boring/bbig"
+	boring "crypto/internal/backend"
+	"crypto/internal/backend/bbig"
 	"crypto/internal/fips140/bigmod"
 	"crypto/internal/fips140/rsa"
 	"crypto/internal/fips140only"
diff --git a/src/crypto/rsa/rsa_test.go b/src/crypto/rsa/rsa_test.go
index 73b0c3749eedb2..1a712a0e1c5d95 100644
--- a/src/crypto/rsa/rsa_test.go
+++ b/src/crypto/rsa/rsa_test.go
@@ -8,7 +8,7 @@ import (
 	"bufio"
 	"bytes"
 	"crypto"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/cryptotest"
 	"crypto/rand"
 	. "crypto/rsa"
@@ -146,6 +146,11 @@ func testKeyBasics(t *testing.T, priv *PrivateKey) {
 	if priv.D.Cmp(priv.N) > 0 {
 		t.Errorf("private exponent too large")
 	}
+	if boring.Enabled && priv.N.BitLen() < 512 {
+		// Some crypto backends (e.g. CNG and OpenSSL with SymCrypt) don't support key sizes
+		// lower than 512 and intentionally fail rather than fall back to Go crypto.
+		t.Skip("skipping allocations test with BoringCrypto")
+	}
 
 	msg := []byte("hi!")
 	enc, err := EncryptPKCS1v15(rand.Reader, &priv.PublicKey, msg)
@@ -226,6 +231,11 @@ func testEverything(t *testing.T, priv *PrivateKey) {
 	if err := priv.Validate(); err != nil {
 		t.Errorf("Validate() failed: %s", err)
 	}
+	if boring.Enabled && priv.N.BitLen() < 512 {
+		// Some crypto backends (e.g. CNG and OpenSSL with SymCrypt) don't support key sizes
+		// lower than 512 and intentionally fail rather than fall back to Go crypto.
+		t.Skip("skipping allocations test with BoringCrypto")
+	}
 
 	msg := []byte("test")
 	enc, err := EncryptPKCS1v15(rand.Reader, &priv.PublicKey, msg)
@@ -853,6 +863,9 @@ func TestDecryptOAEP(t *testing.T) {
 }
 
 func Test2DecryptOAEP(t *testing.T) {
+	if boring.Enabled {
+		t.Skip("Some crypto backends don't supports OAEPOptions.MGFHash.")
+	}
 	random := rand.Reader
 
 	msg := []byte{0xed, 0x36, 0x90, 0x8d, 0xbe, 0xfc, 0x35, 0x40, 0x70, 0x4f, 0xf5, 0x9d, 0x6e, 0xc2, 0xeb, 0xf5, 0x27, 0xae, 0x65, 0xb0, 0x59, 0x29, 0x45, 0x25, 0x8c, 0xc1, 0x91, 0x22}
diff --git a/src/crypto/sha1/sha1.go b/src/crypto/sha1/sha1.go
index d2ffaac0aeb674..23d8ad44d0bd9a 100644
--- a/src/crypto/sha1/sha1.go
+++ b/src/crypto/sha1/sha1.go
@@ -10,7 +10,7 @@ package sha1
 
 import (
 	"crypto"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140only"
 	"errors"
 	"hash"
@@ -266,12 +266,12 @@ func (d *digest) constSum() [Size]byte {
 
 // Sum returns the SHA-1 checksum of the data.
 func Sum(data []byte) [Size]byte {
-	if boring.Enabled {
-		return boring.SHA1(data)
-	}
 	if fips140only.Enabled {
 		panic("crypto/sha1: use of SHA-1 is not allowed in FIPS 140-only mode")
 	}
+	if boring.Enabled {
+		return boring.SHA1(data)
+	}	
 	var d digest
 	d.Reset()
 	d.Write(data)
diff --git a/src/crypto/sha1/sha1_test.go b/src/crypto/sha1/sha1_test.go
index 9d707b7cde5c2d..8e1f92ea7304a8 100644
--- a/src/crypto/sha1/sha1_test.go
+++ b/src/crypto/sha1/sha1_test.go
@@ -8,13 +8,14 @@ package sha1
 
 import (
 	"bytes"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/cryptotest"
 	"crypto/rand"
 	"encoding"
 	"fmt"
 	"hash"
 	"io"
+	"strings"
 	"testing"
 )
 
@@ -107,6 +108,9 @@ func TestGoldenMarshal(t *testing.T) {
 
 		state, err := h.(encoding.BinaryMarshaler).MarshalBinary()
 		if err != nil {
+			if strings.Contains(err.Error(), "hash state is not marshallable") {
+				t.Skip("BinaryMarshaler not supported")
+			}
 			t.Errorf("could not marshal: %v", err)
 			continue
 		}
@@ -214,6 +218,9 @@ func TestLargeHashes(t *testing.T) {
 
 		h := New()
 		if err := h.(encoding.BinaryUnmarshaler).UnmarshalBinary([]byte(test.state)); err != nil {
+			if strings.Contains(err.Error(), "hash state is not marshallable") {
+				t.Skip("BinaryMarshaler not supported")
+			}
 			t.Errorf("test %d could not unmarshal: %v", i, err)
 			continue
 		}
diff --git a/src/crypto/sha256/sha256.go b/src/crypto/sha256/sha256.go
index 069938a22dbc5a..8d0e06b86f4359 100644
--- a/src/crypto/sha256/sha256.go
+++ b/src/crypto/sha256/sha256.go
@@ -8,7 +8,7 @@ package sha256
 
 import (
 	"crypto"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140/sha256"
 	"hash"
 )
@@ -43,7 +43,7 @@ func New() hash.Hash {
 // [encoding.BinaryUnmarshaler] to marshal and unmarshal the internal
 // state of the hash.
 func New224() hash.Hash {
-	if boring.Enabled {
+	if boring.Enabled && boring.SupportsHash(crypto.SHA224) {
 		return boring.NewSHA224()
 	}
 	return sha256.New224()
@@ -63,7 +63,7 @@ func Sum256(data []byte) [Size]byte {
 
 // Sum224 returns the SHA224 checksum of the data.
 func Sum224(data []byte) [Size224]byte {
-	if boring.Enabled {
+	if boring.Enabled && boring.SupportsHash(crypto.SHA224) {
 		return boring.SHA224(data)
 	}
 	h := New224()
diff --git a/src/crypto/sha256/sha256_test.go b/src/crypto/sha256/sha256_test.go
index e1af9640e25547..8896c6e85f4ada 100644
--- a/src/crypto/sha256/sha256_test.go
+++ b/src/crypto/sha256/sha256_test.go
@@ -8,11 +8,13 @@ package sha256
 
 import (
 	"bytes"
+	boring "crypto/internal/backend"
 	"crypto/internal/cryptotest"
 	"encoding"
 	"fmt"
 	"hash"
 	"io"
+	"strings"
 	"testing"
 )
 
@@ -163,6 +165,9 @@ func testGoldenMarshal(t *testing.T) {
 
 				state, err := h.(encoding.BinaryMarshaler).MarshalBinary()
 				if err != nil {
+					if strings.Contains(err.Error(), "hash state is not marshallable") {
+						t.Skip("BinaryMarshaler not supported")
+					}
 					t.Errorf("could not marshal: %v", err)
 					continue
 				}
@@ -206,6 +211,9 @@ func TestMarshalTypeMismatch(t *testing.T) {
 
 	state1, err := h1.(encoding.BinaryMarshaler).MarshalBinary()
 	if err != nil {
+		if strings.Contains(err.Error(), "hash state is not marshallable") {
+			t.Skip("BinaryMarshaler not supported")
+		}
 		t.Errorf("could not marshal: %v", err)
 	}
 
@@ -275,10 +283,18 @@ func safeSum(h hash.Hash) (sum []byte, err error) {
 	return h.Sum(nil), nil
 }
 func TestLargeHashes(t *testing.T) {
+	if boring.Enabled {
+		if _, ok := New().(encoding.BinaryUnmarshaler); !ok {
+			t.Skip("BinaryUnmarshaler not implemented")
+		}
+	}
 	for i, test := range largeUnmarshalTests {
 
 		h := New()
 		if err := h.(encoding.BinaryUnmarshaler).UnmarshalBinary([]byte(test.state)); err != nil {
+			if strings.Contains(err.Error(), "hash state is not marshallable") {
+				t.Skip("BinaryMarshaler not supported")
+			}
 			t.Errorf("test %d could not unmarshal: %v", i, err)
 			continue
 		}
diff --git a/src/crypto/sha512/sha512.go b/src/crypto/sha512/sha512.go
index 1435eac1f5b5dc..17e8501154762a 100644
--- a/src/crypto/sha512/sha512.go
+++ b/src/crypto/sha512/sha512.go
@@ -12,7 +12,7 @@ package sha512
 
 import (
 	"crypto"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140/sha512"
 	"hash"
 )
diff --git a/src/crypto/sha512/sha512_test.go b/src/crypto/sha512/sha512_test.go
index 1fe9d132bb186d..0692be8461e964 100644
--- a/src/crypto/sha512/sha512_test.go
+++ b/src/crypto/sha512/sha512_test.go
@@ -8,12 +8,14 @@ package sha512
 
 import (
 	"bytes"
+	boring "crypto/internal/backend"
 	"crypto/internal/cryptotest"
 	"encoding"
 	"encoding/hex"
 	"fmt"
 	"hash"
 	"io"
+	"strings"
 	"testing"
 )
 
@@ -751,6 +753,9 @@ func testGoldenMarshal(t *testing.T) {
 
 				state, err := h.(encoding.BinaryMarshaler).MarshalBinary()
 				if err != nil {
+					if strings.Contains(err.Error(), "hash state is not marshallable") {
+						t.Skip("BinaryMarshaler not supported")
+					}
 					t.Errorf("could not marshal: %v", err)
 					return
 				}
@@ -807,6 +812,9 @@ func TestMarshalMismatch(t *testing.T) {
 
 			state, err := h1.(encoding.BinaryMarshaler).MarshalBinary()
 			if err != nil {
+				if strings.Contains(err.Error(), "hash state is not marshallable") {
+					t.Skip("BinaryMarshaler not supported")
+				}
 				t.Errorf("i=%d: could not marshal: %v", i, err)
 				continue
 			}
@@ -880,10 +888,18 @@ func safeSum(h hash.Hash) (sum []byte, err error) {
 }
 
 func TestLargeHashes(t *testing.T) {
+	if boring.Enabled {
+		if _, ok := New().(encoding.BinaryUnmarshaler); !ok {
+			t.Skip("BinaryUnmarshaler not implemented")
+		}
+	}
 	for i, test := range largeUnmarshalTests {
 
 		h := New()
 		if err := h.(encoding.BinaryUnmarshaler).UnmarshalBinary([]byte(test.state)); err != nil {
+			if strings.Contains(err.Error(), "hash state is not marshallable") {
+				t.Skip("BinaryMarshaler not supported")
+			}
 			t.Errorf("test %d could not unmarshal: %v", i, err)
 			continue
 		}
diff --git a/src/crypto/tls/cipher_suites.go b/src/crypto/tls/cipher_suites.go
index 01d65688284f97..d8a26c24024348 100644
--- a/src/crypto/tls/cipher_suites.go
+++ b/src/crypto/tls/cipher_suites.go
@@ -10,7 +10,7 @@ import (
 	"crypto/cipher"
 	"crypto/des"
 	"crypto/hmac"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	fipsaes "crypto/internal/fips140/aes"
 	"crypto/internal/fips140/aes/gcm"
 	"crypto/rc4"
diff --git a/src/crypto/tls/fipsonly/fipsonly.go b/src/crypto/tls/fipsonly/fipsonly.go
index e702f44e986746..e506a0d8841237 100644
--- a/src/crypto/tls/fipsonly/fipsonly.go
+++ b/src/crypto/tls/fipsonly/fipsonly.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto
+//go:build goexperiment.systemcrypto
 
 // Package fipsonly restricts all TLS configuration to FIPS-approved settings.
 //
diff --git a/src/crypto/tls/fipsonly/fipsonly_test.go b/src/crypto/tls/fipsonly/fipsonly_test.go
index 027bc22c33c921..eba08da985f832 100644
--- a/src/crypto/tls/fipsonly/fipsonly_test.go
+++ b/src/crypto/tls/fipsonly/fipsonly_test.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto
+//go:build goexperiment.systemcrypto
 
 package fipsonly
 
diff --git a/src/crypto/tls/handshake_client.go b/src/crypto/tls/handshake_client.go
index 38bd417a0dca72..8c1ae3c7ec5485 100644
--- a/src/crypto/tls/handshake_client.go
+++ b/src/crypto/tls/handshake_client.go
@@ -11,11 +11,11 @@ import (
 	"crypto/ecdsa"
 	"crypto/ed25519"
 	"crypto/internal/fips140/mlkem"
-	"crypto/internal/fips140/tls13"
 	"crypto/internal/hpke"
 	"crypto/rsa"
 	"crypto/subtle"
 	"crypto/tls/internal/fips140tls"
+	"crypto/tls/internal/tls13"
 	"crypto/x509"
 	"errors"
 	"fmt"
@@ -549,7 +549,15 @@ func (c *Conn) pickTLSVersion(serverHello *serverHelloMsg) error {
 
 // Does the handshake, either a full one or resumes old session. Requires hs.c,
 // hs.hello, hs.serverHello, and, optionally, hs.session to be set.
-func (hs *clientHandshakeState) handshake() error {
+func (hs *clientHandshakeState) handshake() (err error) {
+	defer func() {
+		if err == nil {
+			err = recoverFromBoringPRFError()
+			if err != nil {
+				hs.c.sendAlert(alertInternalError)
+			}
+		}
+	}()
 	c := hs.c
 
 	isResume, err := hs.processServerHello()
diff --git a/src/crypto/tls/handshake_client_tls13.go b/src/crypto/tls/handshake_client_tls13.go
index c0396e75796add..2c00e119cb66e4 100644
--- a/src/crypto/tls/handshake_client_tls13.go
+++ b/src/crypto/tls/handshake_client_tls13.go
@@ -8,12 +8,12 @@ import (
 	"bytes"
 	"context"
 	"crypto"
+	"crypto/hkdf"
 	"crypto/hmac"
-	"crypto/internal/fips140/hkdf"
 	"crypto/internal/fips140/mlkem"
-	"crypto/internal/fips140/tls13"
 	"crypto/rsa"
 	"crypto/subtle"
+	"crypto/tls/internal/tls13"
 	"errors"
 	"hash"
 	"slices"
@@ -90,8 +90,12 @@ func (hs *clientHandshakeStateTLS13) handshake() error {
 		confTranscript.Write(hs.serverHello.original[:30])
 		confTranscript.Write(make([]byte, 8))
 		confTranscript.Write(hs.serverHello.original[38:])
+		secret, err := hkdf.Extract(hs.suite.hash.New, hs.echContext.innerHello.random, nil)
+		if err != nil {
+			return err
+		}
 		acceptConfirmation := tls13.ExpandLabel(hs.suite.hash.New,
-			hkdf.Extract(hs.suite.hash.New, hs.echContext.innerHello.random, nil),
+			secret,
 			"ech accept confirmation",
 			confTranscript.Sum(nil),
 			8,
@@ -264,8 +268,12 @@ func (hs *clientHandshakeStateTLS13) processHelloRetryRequest() error {
 			copy(hrrHello, hs.serverHello.original)
 			hrrHello = bytes.Replace(hrrHello, hs.serverHello.encryptedClientHello, make([]byte, 8), 1)
 			confTranscript.Write(hrrHello)
+			secret, err := hkdf.Extract(hs.suite.hash.New, hs.echContext.innerHello.random, nil)
+			if err != nil {
+				return err
+			}
 			acceptConfirmation := tls13.ExpandLabel(hs.suite.hash.New,
-				hkdf.Extract(hs.suite.hash.New, hs.echContext.innerHello.random, nil),
+				secret,
 				"hrr ech accept confirmation",
 				confTranscript.Sum(nil),
 				8,
diff --git a/src/crypto/tls/handshake_server.go b/src/crypto/tls/handshake_server.go
index 7c75977ad3ffb2..b9db95ca7b9d5a 100644
--- a/src/crypto/tls/handshake_server.go
+++ b/src/crypto/tls/handshake_server.go
@@ -64,7 +64,15 @@ func (c *Conn) serverHandshake(ctx context.Context) error {
 	return hs.handshake()
 }
 
-func (hs *serverHandshakeState) handshake() error {
+func (hs *serverHandshakeState) handshake() (err error) {
+	defer func() {
+		if err == nil {
+			err = recoverFromBoringPRFError()
+			if err != nil {
+				hs.c.sendAlert(alertInternalError)
+			}
+		}
+	}()
 	c := hs.c
 
 	if err := hs.processClientHello(); err != nil {
diff --git a/src/crypto/tls/handshake_server_tls13.go b/src/crypto/tls/handshake_server_tls13.go
index 76fff6974e7403..3ef8b56e5c7898 100644
--- a/src/crypto/tls/handshake_server_tls13.go
+++ b/src/crypto/tls/handshake_server_tls13.go
@@ -8,13 +8,14 @@ import (
 	"bytes"
 	"context"
 	"crypto"
+	"crypto/hkdf"
 	"crypto/hmac"
-	"crypto/internal/fips140/hkdf"
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140/mlkem"
-	"crypto/internal/fips140/tls13"
 	"crypto/internal/hpke"
 	"crypto/rsa"
 	"crypto/tls/internal/fips140tls"
+	"crypto/tls/internal/tls13"
 	"errors"
 	"hash"
 	"internal/byteorder"
@@ -470,15 +471,19 @@ func (hs *serverHandshakeStateTLS13) checkForResumption() error {
 // interfaces implemented by standard library hashes to clone the state of in
 // to a new instance of h. It returns nil if the operation fails.
 func cloneHash(in hash.Hash, h crypto.Hash) hash.Hash {
+	if boring.Enabled {
+		// CNG and OpenSSL with SymCrypt hash functions do not implement the
+		// encoding.BinaryMarshaler interface, but they do implement the Clone method.
+		if cloner, ok := in.(interface{ Clone() hash.Hash }); ok {
+			return cloner.Clone()
+		}
+	}
 	// Recreate the interface to avoid importing encoding.
 	type binaryMarshaler interface {
 		MarshalBinary() (data []byte, err error)
 		UnmarshalBinary(data []byte) error
 	}
 	marshaler, ok := in.(binaryMarshaler)
-	if !ok {
-		return nil
-	}
 	state, err := marshaler.MarshalBinary()
 	if err != nil {
 		return nil
@@ -572,8 +577,12 @@ func (hs *serverHandshakeStateTLS13) doHelloRetryRequest(selectedGroup CurveID)
 		if err := transcriptMsg(helloRetryRequest, confTranscript); err != nil {
 			return nil, err
 		}
+		secret, err := hkdf.Extract(hs.suite.hash.New, hs.clientHello.random, nil)
+		if err != nil {
+			return nil, err
+		}
 		acceptConfirmation := tls13.ExpandLabel(hs.suite.hash.New,
-			hkdf.Extract(hs.suite.hash.New, hs.clientHello.random, nil),
+			secret,
 			"hrr ech accept confirmation",
 			confTranscript.Sum(nil),
 			8,
@@ -734,9 +743,13 @@ func (hs *serverHandshakeStateTLS13) sendServerParameters() error {
 		if err := transcriptMsg(hs.hello, echTranscript); err != nil {
 			return err
 		}
+		secret, err := hkdf.Extract(hs.suite.hash.New, hs.clientHello.random, nil)
+		if err != nil {
+			return err
+		}
 		// compute the acceptance message
 		acceptConfirmation := tls13.ExpandLabel(hs.suite.hash.New,
-			hkdf.Extract(hs.suite.hash.New, hs.clientHello.random, nil),
+			secret,
 			"ech accept confirmation",
 			echTranscript.Sum(nil),
 			8,
diff --git a/src/crypto/tls/internal/fips140tls/fipstls.go b/src/crypto/tls/internal/fips140tls/fipstls.go
index 24d78d60cf5b64..0b87185683ab8b 100644
--- a/src/crypto/tls/internal/fips140tls/fipstls.go
+++ b/src/crypto/tls/internal/fips140tls/fipstls.go
@@ -6,14 +6,14 @@
 package fips140tls
 
 import (
-	"crypto/internal/fips140"
+	"crypto/fips140"
 	"sync/atomic"
 )
 
 var required atomic.Bool
 
 func init() {
-	if fips140.Enabled {
+	if fips140.Enabled() {
 		Force()
 	}
 }
diff --git a/src/crypto/tls/internal/tls13/doc.go b/src/crypto/tls/internal/tls13/doc.go
new file mode 100644
index 00000000000000..1adf3098356307
--- /dev/null
+++ b/src/crypto/tls/internal/tls13/doc.go
@@ -0,0 +1,18 @@
+// Copyright 2024 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+/*
+Microsoft Go only package.
+
+TLS 1.3 Key Schedule is normally not part of the FIPS boundary, but upstream Go
+decided to include it in the FIPS boundary to facilitate the FIPS 140-3 certification
+process.
+
+The problem is that crypto/internal/fips140/tls13 uses crypto/internal/fips140/hkdf,
+which can't be patched to use other backends.
+
+To solve this problem, we created this package, which is a direct copy of
+crypto/internal/fips140/tls13, but uses crypto/hkdf instead of crypto/internal/fips140/hkdf.
+*/
+package tls13
diff --git a/src/crypto/tls/internal/tls13/tls13.go b/src/crypto/tls/internal/tls13/tls13.go
new file mode 100644
index 00000000000000..573896b9c1e6a8
--- /dev/null
+++ b/src/crypto/tls/internal/tls13/tls13.go
@@ -0,0 +1,182 @@
+// Copyright 2024 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Package tls13 implements the TLS 1.3 Key Schedule as specified in RFC 8446,
+// Section 7.1 and allowed by FIPS 140-3 IG 2.4.B Resolution 7.
+package tls13
+
+import (
+	"crypto/hkdf"
+	"hash"
+	"internal/byteorder"
+)
+
+// We don't set the service indicator in this package but we delegate that to
+// the underlying functions because the TLS 1.3 KDF does not have a standard of
+// its own.
+
+// ExpandLabel implements HKDF-Expand-Label from RFC 8446, Section 7.1.
+func ExpandLabel[H hash.Hash](hash func() H, secret []byte, label string, context []byte, length int) []byte {
+	if len("tls13 ")+len(label) > 255 || len(context) > 255 {
+		// It should be impossible for this to panic: labels are fixed strings,
+		// and context is either a fixed-length computed hash, or parsed from a
+		// field which has the same length limitation.
+		//
+		// Another reasonable approach might be to return a randomized slice if
+		// we encounter an error, which would break the connection, but avoid
+		// panicking. This would perhaps be safer but significantly more
+		// confusing to users.
+		panic("tls13: label or context too long")
+	}
+	hkdfLabel := make([]byte, 0, 2+1+len("tls13 ")+len(label)+1+len(context))
+	hkdfLabel = byteorder.BEAppendUint16(hkdfLabel, uint16(length))
+	hkdfLabel = append(hkdfLabel, byte(len("tls13 ")+len(label)))
+	hkdfLabel = append(hkdfLabel, "tls13 "...)
+	hkdfLabel = append(hkdfLabel, label...)
+	hkdfLabel = append(hkdfLabel, byte(len(context)))
+	hkdfLabel = append(hkdfLabel, context...)
+	key, err := hkdf.Expand(hash, secret, string(hkdfLabel), length)
+	if err != nil {
+		panic(err)
+	}
+	return key
+}
+
+func extract[H hash.Hash](hash func() H, newSecret, currentSecret []byte) []byte {
+	if newSecret == nil {
+		newSecret = make([]byte, hash().Size())
+	}
+	prk, err := hkdf.Extract(hash, newSecret, currentSecret)
+	if err != nil {
+		panic(err)
+	}
+	return prk
+}
+
+func deriveSecret[H hash.Hash](hash func() H, secret []byte, label string, transcript hash.Hash) []byte {
+	if transcript == nil {
+		transcript = hash()
+	}
+	return ExpandLabel(hash, secret, label, transcript.Sum(nil), transcript.Size())
+}
+
+const (
+	resumptionBinderLabel         = "res binder"
+	clientEarlyTrafficLabel       = "c e traffic"
+	clientHandshakeTrafficLabel   = "c hs traffic"
+	serverHandshakeTrafficLabel   = "s hs traffic"
+	clientApplicationTrafficLabel = "c ap traffic"
+	serverApplicationTrafficLabel = "s ap traffic"
+	earlyExporterLabel            = "e exp master"
+	exporterLabel                 = "exp master"
+	resumptionLabel               = "res master"
+)
+
+type EarlySecret struct {
+	secret []byte
+	hash   func() hash.Hash
+}
+
+func NewEarlySecret[H hash.Hash](h func() H, psk []byte) *EarlySecret {
+	return &EarlySecret{
+		secret: extract(h, psk, nil),
+		hash:   func() hash.Hash { return h() },
+	}
+}
+
+func (s *EarlySecret) ResumptionBinderKey() []byte {
+	return deriveSecret(s.hash, s.secret, resumptionBinderLabel, nil)
+}
+
+// ClientEarlyTrafficSecret derives the client_early_traffic_secret from the
+// early secret and the transcript up to the ClientHello.
+func (s *EarlySecret) ClientEarlyTrafficSecret(transcript hash.Hash) []byte {
+	return deriveSecret(s.hash, s.secret, clientEarlyTrafficLabel, transcript)
+}
+
+type HandshakeSecret struct {
+	secret []byte
+	hash   func() hash.Hash
+}
+
+func (s *EarlySecret) HandshakeSecret(sharedSecret []byte) *HandshakeSecret {
+	derived := deriveSecret(s.hash, s.secret, "derived", nil)
+	return &HandshakeSecret{
+		secret: extract(s.hash, sharedSecret, derived),
+		hash:   s.hash,
+	}
+}
+
+// ClientHandshakeTrafficSecret derives the client_handshake_traffic_secret from
+// the handshake secret and the transcript up to the ServerHello.
+func (s *HandshakeSecret) ClientHandshakeTrafficSecret(transcript hash.Hash) []byte {
+	return deriveSecret(s.hash, s.secret, clientHandshakeTrafficLabel, transcript)
+}
+
+// ServerHandshakeTrafficSecret derives the server_handshake_traffic_secret from
+// the handshake secret and the transcript up to the ServerHello.
+func (s *HandshakeSecret) ServerHandshakeTrafficSecret(transcript hash.Hash) []byte {
+	return deriveSecret(s.hash, s.secret, serverHandshakeTrafficLabel, transcript)
+}
+
+type MasterSecret struct {
+	secret []byte
+	hash   func() hash.Hash
+}
+
+func (s *HandshakeSecret) MasterSecret() *MasterSecret {
+	derived := deriveSecret(s.hash, s.secret, "derived", nil)
+	return &MasterSecret{
+		secret: extract(s.hash, nil, derived),
+		hash:   s.hash,
+	}
+}
+
+// ClientApplicationTrafficSecret derives the client_application_traffic_secret_0
+// from the master secret and the transcript up to the server Finished.
+func (s *MasterSecret) ClientApplicationTrafficSecret(transcript hash.Hash) []byte {
+	return deriveSecret(s.hash, s.secret, clientApplicationTrafficLabel, transcript)
+}
+
+// ServerApplicationTrafficSecret derives the server_application_traffic_secret_0
+// from the master secret and the transcript up to the server Finished.
+func (s *MasterSecret) ServerApplicationTrafficSecret(transcript hash.Hash) []byte {
+	return deriveSecret(s.hash, s.secret, serverApplicationTrafficLabel, transcript)
+}
+
+// ResumptionMasterSecret derives the resumption_master_secret from the master secret
+// and the transcript up to the client Finished.
+func (s *MasterSecret) ResumptionMasterSecret(transcript hash.Hash) []byte {
+	return deriveSecret(s.hash, s.secret, resumptionLabel, transcript)
+}
+
+type ExporterMasterSecret struct {
+	secret []byte
+	hash   func() hash.Hash
+}
+
+// ExporterMasterSecret derives the exporter_master_secret from the master secret
+// and the transcript up to the server Finished.
+func (s *MasterSecret) ExporterMasterSecret(transcript hash.Hash) *ExporterMasterSecret {
+	return &ExporterMasterSecret{
+		secret: deriveSecret(s.hash, s.secret, exporterLabel, transcript),
+		hash:   s.hash,
+	}
+}
+
+// EarlyExporterMasterSecret derives the exporter_master_secret from the early secret
+// and the transcript up to the ClientHello.
+func (s *EarlySecret) EarlyExporterMasterSecret(transcript hash.Hash) *ExporterMasterSecret {
+	return &ExporterMasterSecret{
+		secret: deriveSecret(s.hash, s.secret, earlyExporterLabel, transcript),
+		hash:   s.hash,
+	}
+}
+
+func (s *ExporterMasterSecret) Exporter(label string, context []byte, length int) []byte {
+	secret := deriveSecret(s.hash, s.secret, label, nil)
+	h := s.hash()
+	h.Write(context)
+	return ExpandLabel(s.hash, secret, "exporter", h.Sum(nil), length)
+}
diff --git a/src/crypto/tls/key_schedule.go b/src/crypto/tls/key_schedule.go
index 38d6d3f7be1673..b236ae44a34030 100644
--- a/src/crypto/tls/key_schedule.go
+++ b/src/crypto/tls/key_schedule.go
@@ -8,7 +8,7 @@ import (
 	"crypto/ecdh"
 	"crypto/hmac"
 	"crypto/internal/fips140/mlkem"
-	"crypto/internal/fips140/tls13"
+	"crypto/tls/internal/tls13"
 	"errors"
 	"hash"
 	"io"
diff --git a/src/crypto/tls/prf.go b/src/crypto/tls/prf.go
index e7369542a73270..ff52175e4ac636 100644
--- a/src/crypto/tls/prf.go
+++ b/src/crypto/tls/prf.go
@@ -7,6 +7,7 @@ package tls
 import (
 	"crypto"
 	"crypto/hmac"
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140/tls12"
 	"crypto/md5"
 	"crypto/sha1"
@@ -47,9 +48,42 @@ func pHash(result, secret, seed []byte, hash func() hash.Hash) {
 	}
 }
 
+type boringPRFError struct {
+	err error
+}
+
+func (e *boringPRFError) Error() string {
+	return e.err.Error()
+}
+
+// recoverFromBoringPRFError recovers from a panic caused by the boring backend.
+// It returns the error if it was a boringPRFError, or panics if the panic was
+// caused by something else.
+func recoverFromBoringPRFError() error {
+	if p := recover(); p != nil {
+		if err, ok := p.(boringPRFError); ok {
+			// Could happen, for example, if the seed is too large. The Go implementation doesn't limit the seed size,
+			// as RFC 5705 doesn't specify a limit, but stock OpenSSL restrict it to 1024 and CNG to 256.
+			return err.err
+		}
+		panic(p)
+	}
+	return nil
+}
+
+func panicBoringPRFError(err error) {
+	panic(boringPRFError{err})
+}
+
 // prf10 implements the TLS 1.0 pseudo-random function, as defined in RFC 2246, Section 5.
 func prf10(secret []byte, label string, seed []byte, keyLen int) []byte {
 	result := make([]byte, keyLen)
+	if boring.Enabled && boring.SupportsTLS1PRF() {
+		if err := boring.TLS1PRF(result, secret, []byte(label), seed, nil); err != nil {
+			panicBoringPRFError(fmt.Errorf("crypto/tls: prf10: %v", err))
+		}
+		return result
+	}
 	hashSHA1 := sha1.New
 	hashMD5 := md5.New
 
@@ -72,6 +106,13 @@ func prf10(secret []byte, label string, seed []byte, keyLen int) []byte {
 // prf12 implements the TLS 1.2 pseudo-random function, as defined in RFC 5246, Section 5.
 func prf12(hashFunc func() hash.Hash) prfFunc {
 	return func(secret []byte, label string, seed []byte, keyLen int) []byte {
+		if boring.Enabled && boring.SupportsTLS1PRF() {
+			result := make([]byte, keyLen)
+			if err := boring.TLS1PRF(result, secret, []byte(label), seed, hashFunc); err != nil {
+				panicBoringPRFError(fmt.Errorf("crypto/tls: prf12: %v", err))
+			}
+			return result
+		}
 		return tls12.PRF(hashFunc, secret, label, seed, keyLen)
 	}
 }
diff --git a/src/go/build/deps_test.go b/src/go/build/deps_test.go
index ab5539f978a266..484c95dfb65f60 100644
--- a/src/go/build/deps_test.go
+++ b/src/go/build/deps_test.go
@@ -495,7 +495,7 @@ var depsRules = `
 
 	syscall < crypto/internal/backend/fips140;
 
-	FIPS, internal/godebug < crypto/fips140;
+	FIPS, internal/godebug, crypto/internal/backend/fips140 < crypto/fips140;
 
 	crypto, hash !< FIPS;
 
@@ -539,6 +539,7 @@ var depsRules = `
 	  crypto/pbkdf2,
 	  crypto/ecdh,
 	  crypto/mlkem
+	< crypto/tls/internal/tls13
 	< CRYPTO;
 
 	CGO, fmt, net !< CRYPTO;
@@ -564,7 +565,7 @@ var depsRules = `
 
 	# TLS, Prince of Dependencies.
 
-	FIPS, sync/atomic < crypto/tls/internal/fips140tls;
+	crypto/fips140, sync/atomic < crypto/tls/internal/fips140tls;
 
 	crypto/internal/boring/sig, crypto/tls/internal/fips140tls < crypto/tls/fipsonly;
 
diff --git a/src/hash/boring_test.go b/src/hash/boring_test.go
new file mode 100644
index 00000000000000..52748c44698076
--- /dev/null
+++ b/src/hash/boring_test.go
@@ -0,0 +1,9 @@
+// Copyright 2024 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build goexperiment.systemcrypto
+
+package hash_test
+
+const boringEnabled = true
diff --git a/src/hash/example_test.go b/src/hash/example_test.go
index f07b9aaa2c4898..b380537215634d 100644
--- a/src/hash/example_test.go
+++ b/src/hash/example_test.go
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
+//go:build !goexperiment.systemcrypto
+
 package hash_test
 
 import (
diff --git a/src/hash/marshal_test.go b/src/hash/marshal_test.go
index 3091f7a67acede..d952cf45797ac6 100644
--- a/src/hash/marshal_test.go
+++ b/src/hash/marshal_test.go
@@ -21,6 +21,7 @@ import (
 	"hash/crc32"
 	"hash/crc64"
 	"hash/fnv"
+	"strings"
 	"testing"
 )
 
@@ -80,6 +81,9 @@ func TestMarshalHash(t *testing.T) {
 			}
 			enc, err := h2m.MarshalBinary()
 			if err != nil {
+				if strings.Contains(err.Error(), "hash state is not marshallable") {
+					t.Skip("BinaryMarshaler not supported")
+				}
 				t.Fatalf("MarshalBinary: %v", err)
 			}
 			if !bytes.Equal(enc, tt.golden) {
diff --git a/src/hash/notboring_test.go b/src/hash/notboring_test.go
new file mode 100644
index 00000000000000..11dc691600b110
--- /dev/null
+++ b/src/hash/notboring_test.go
@@ -0,0 +1,9 @@
+// Copyright 2024 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build !goexperiment.systemcrypto
+
+package hash_test
+
+const boringEnabled = false
diff --git a/src/net/lookup_test.go b/src/net/lookup_test.go
index 514cbd098ae772..8ec689416dde1d 100644
--- a/src/net/lookup_test.go
+++ b/src/net/lookup_test.go
@@ -1501,6 +1501,9 @@ func TestLookupPortIPNetworkString(t *testing.T) {
 }
 
 func TestLookupNoSuchHost(t *testing.T) {
+	if runtime.GOOS == "darwin" {
+		t.Skip("skipping on darwin; see https://github.com/microsoft/go/issues/1394")
+	}
 	mustHaveExternalNetwork(t)
 
 	const testNXDOMAIN = "invalid.invalid."
diff --git a/src/net/smtp/smtp_test.go b/src/net/smtp/smtp_test.go
index 389eda9ad54b99..110d60beb0e70c 100644
--- a/src/net/smtp/smtp_test.go
+++ b/src/net/smtp/smtp_test.go
@@ -1136,40 +1136,60 @@ func sendMail(hostPort string) error {
 
 // localhostCert is a PEM-encoded TLS cert generated from src/crypto/tls:
 //
-//	go run generate_cert.go --rsa-bits 1024 --host 127.0.0.1,::1,example.com \
+//	Use a 2048-bits RSA key to make it FIPS-compliant.
+//	go run generate_cert.go --rsa-bits 2048 --host 127.0.0.1,::1,example.com \
 //		--ca --start-date "Jan 1 00:00:00 1970" --duration=1000000h
 var localhostCert = []byte(`
 -----BEGIN CERTIFICATE-----
-MIICFDCCAX2gAwIBAgIRAK0xjnaPuNDSreeXb+z+0u4wDQYJKoZIhvcNAQELBQAw
-EjEQMA4GA1UEChMHQWNtZSBDbzAgFw03MDAxMDEwMDAwMDBaGA8yMDg0MDEyOTE2
-MDAwMFowEjEQMA4GA1UEChMHQWNtZSBDbzCBnzANBgkqhkiG9w0BAQEFAAOBjQAw
-gYkCgYEA0nFbQQuOWsjbGtejcpWz153OlziZM4bVjJ9jYruNw5n2Ry6uYQAffhqa
-JOInCmmcVe2siJglsyH9aRh6vKiobBbIUXXUU1ABd56ebAzlt0LobLlx7pZEMy30
-LqIi9E6zmL3YvdGzpYlkFRnRrqwEtWYbGBf3znO250S56CCWH2UCAwEAAaNoMGYw
-DgYDVR0PAQH/BAQDAgKkMBMGA1UdJQQMMAoGCCsGAQUFBwMBMA8GA1UdEwEB/wQF
-MAMBAf8wLgYDVR0RBCcwJYILZXhhbXBsZS5jb22HBH8AAAGHEAAAAAAAAAAAAAAA
-AAAAAAEwDQYJKoZIhvcNAQELBQADgYEAbZtDS2dVuBYvb+MnolWnCNqvw1w5Gtgi
-NmvQQPOMgM3m+oQSCPRTNGSg25e1Qbo7bgQDv8ZTnq8FgOJ/rbkyERw2JckkHpD4
-n4qcK27WkEDBtQFlPihIM8hLIuzWoi/9wygiElTy/tVL3y7fGCvY2/k1KBthtZGF
-tN8URjVmyEo=
+MIIDOTCCAiGgAwIBAgIQKhWw7zkzXjX78HaPlVbNrjANBgkqhkiG9w0BAQsFADAS
+MRAwDgYDVQQKEwdBY21lIENvMCAXDTcwMDEwMTAwMDAwMFoYDzIwODQwMTI5MTYw
+MDAwWjASMRAwDgYDVQQKEwdBY21lIENvMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A
+MIIBCgKCAQEAy1EYLA8IFvZyUPY+uI7KToneaQPvIzQiOeWlDnFnoanw6h3KpoVc
++yNbinK41WfXoSN/1kJ9gmGiFhJTPZ4rQ7DJsD7ethcpuz4uIimdWPohcBzwgbx4
+wjhUgfUsCO6m76fFqrhbkHMDiS2iUjg2gyMVQCrqi8EuBW16yFQdJqPU04p+2rYw
+eJ9lzdeSLR4yvx7p1JS8sS4DbSyrAUaJ9J1sH/gu0nSHNMo7WtIu9K8JmPeYR4X5
+5KLURBU9PmvoGW+5ss/xS6SnacHAD9FebNPQqGB/soBA9gdJIN+5KW0xcE38Zz5Q
+wAAUiU+VlWuZmge0sI8Ix8uIPIvGQSKN0wIDAQABo4GIMIGFMA4GA1UdDwEB/wQE
+AwICpDATBgNVHSUEDDAKBggrBgEFBQcDATAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud
+DgQWBBRNMP9Cr0yrXpMpsgEtDr8FPmUEazAuBgNVHREEJzAlggtleGFtcGxlLmNv
+bYcEfwAAAYcQAAAAAAAAAAAAAAAAAAAAATANBgkqhkiG9w0BAQsFAAOCAQEAF0/z
+KEnZrAsz4ov4fEvKY42EbKPm8s0pklPLmKVIh/iS7jTxxxvgDtOToiJ6IXY8Cfb3
+nG1i78YakoVPUL5Cfh5LKDefMoefk6575ur2+gSdzgNmKUnlVfOMfpflia/ugATZ
+5ORhpmKRKWzwXQ67S5XeVlZAehTsywQstsDu8WEVoSUnRSk1jZsCThOQfdlpox+K
+71rGPSTxB9yCHMzZsk4xyZlGLaC0vDSJ+Zb5gWvAcvkSnpREvmc3/9TaW/lbUed6
+uhO17lARcUhPCzkR5wAZCo/PihHMSXL8cqT4QdIux75OBxB/3EgLHL7KQw28A50g
+DogldK8zx1ZADmupUA==
 -----END CERTIFICATE-----`)
 
 // localhostKey is the private key for localhostCert.
 var localhostKey = []byte(testingKey(`
 -----BEGIN RSA TESTING KEY-----
-MIICXgIBAAKBgQDScVtBC45ayNsa16NylbPXnc6XOJkzhtWMn2Niu43DmfZHLq5h
-AB9+Gpok4icKaZxV7ayImCWzIf1pGHq8qKhsFshRddRTUAF3np5sDOW3QuhsuXHu
-lkQzLfQuoiL0TrOYvdi90bOliWQVGdGurAS1ZhsYF/fOc7bnRLnoIJYfZQIDAQAB
-AoGBAMst7OgpKyFV6c3JwyI/jWqxDySL3caU+RuTTBaodKAUx2ZEmNJIlx9eudLA
-kucHvoxsM/eRxlxkhdFxdBcwU6J+zqooTnhu/FE3jhrT1lPrbhfGhyKnUrB0KKMM
-VY3IQZyiehpxaeXAwoAou6TbWoTpl9t8ImAqAMY8hlULCUqlAkEA+9+Ry5FSYK/m
-542LujIcCaIGoG1/Te6Sxr3hsPagKC2rH20rDLqXwEedSFOpSS0vpzlPAzy/6Rbb
-PHTJUhNdwwJBANXkA+TkMdbJI5do9/mn//U0LfrCR9NkcoYohxfKz8JuhgRQxzF2
-6jpo3q7CdTuuRixLWVfeJzcrAyNrVcBq87cCQFkTCtOMNC7fZnCTPUv+9q1tcJyB
-vNjJu3yvoEZeIeuzouX9TJE21/33FaeDdsXbRhQEj23cqR38qFHsF1qAYNMCQQDP
-QXLEiJoClkR2orAmqjPLVhR3t2oB3INcnEjLNSq8LHyQEfXyaFfu4U9l5+fRPL2i
-jiC0k/9L5dHUsF0XZothAkEA23ddgRs+Id/HxtojqqUT27B8MT/IGNrYsp4DvS/c
-qgkeluku4GjxRlDMBuXk94xOBEinUs+p/hwP1Alll80Tpg==
+MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDLURgsDwgW9nJQ
+9j64jspOid5pA+8jNCI55aUOcWehqfDqHcqmhVz7I1uKcrjVZ9ehI3/WQn2CYaIW
+ElM9nitDsMmwPt62Fym7Pi4iKZ1Y+iFwHPCBvHjCOFSB9SwI7qbvp8WquFuQcwOJ
+LaJSODaDIxVAKuqLwS4FbXrIVB0mo9TTin7atjB4n2XN15ItHjK/HunUlLyxLgNt
+LKsBRon0nWwf+C7SdIc0yjta0i70rwmY95hHhfnkotREFT0+a+gZb7myz/FLpKdp
+wcAP0V5s09CoYH+ygED2B0kg37kpbTFwTfxnPlDAABSJT5WVa5maB7SwjwjHy4g8
+i8ZBIo3TAgMBAAECggEAc7dv/oN/ozIY1iOQhxId6p1lTHfEv1CIulMNoi7BQK2s
+RFM4Z5Y32WfCTgYFVNCJVVkTBStKq85Npio/3i4Libcw03K05wY/5iX5s8/jkiSq
+q1iNOgm+4SuWTXDw4xSRRo1CX2wWERykwoqKfCkqPXDWQ3Mpkukb/FLXMvVMshRA
+9v9L6MyrCnsFHl8q2J6hcC+RQJ0pb5I4NF6KhMxABWxxxlDO0zYLA0wfhEn8nj/l
+J37QLHmsA7pzxo+NqDTPgpfBuuTbRVGMkC+fPCXYinbubBeURFO2j2yBlseK+Vbd
+sEffiAnPr4ocCz0k0tHAMMY7hKHup2HWuJGFu0IhAQKBgQDkKFEEcYWNx5Ybl1LV
+qr2qIYofpFL+Gu5MWSZxzZbE8u9v0tTsp8SRhXkgjeHY6qjBUBnLgklOKwSigQAm
+j9de44cXjnUIArzeAHsH3fzpYrLfsvBla6wQyr34D0chVCZ0cX/s/zXkSN4PcEkA
+GGfKAENrGskDyc4uq1sIactu8wKBgQDkIL/XT7ysvsaxA+SfIs2CHgb8GNKgtoI1
+QyR0+MfeJGCLwI9qcLbVzXda34qrzQw3YLIm2VHqhzJ4zb0gnyJ4adPZYwpLTgiU
+jVksBVIwBTfbxYvF2+07poCSobCFKLGQnAujhDDIGDAUKQXQmFcqUNWw0QHfQzkS
+xs36H27doQKBgQCjM8+YLRgKbc0LGXhwTHz1GJ6zuZiAGYWB6XddimEhqmDpjVcv
+nWY3bdFSHwuBXYGvHfwFncGP/6eGEl6oNtYpEvoMOKOwQj0VVCStYPZLf4VSDK52
+7ckcDdpLeao4xffn7VRDk97Z1+G4C2q8fbioPv36vCMz6YPp0DsCzqJtTwKBgCUN
+4LtDW10fu7xC6p6ik4jgAbhu+79ZBbtLBZ/uTOCbPgdVJrZeSoRd1FYxWx/etW5F
+SYqf3/tdLGiM2nxy/LFcVynHOYPTz/b5IpPQ5XGhV1peMv7XYyg+OkIW+0oVuwnH
+HujXbukBbMXJiAVCyV25NYx71ncCP0H6grhu5J4hAoGAUaketZWHD/ks9JCoPtfy
+pNnXqrIvTp1cSGJpVUQT/DUqAjevyZ5Q8PFPf09BZ6uYlXtCqsp7pA/fqNdlJRPR
+tHRjpZ5XauBiFdpRNH4tJBTiWWhyuWhkWn369Az7HP3CIlJLeq2FlKCvMClcO4op
+Qc9LHT7jqtcy+LqAVBpsJ/o=
 -----END RSA TESTING KEY-----`))
 
 func testingKey(s string) string { return strings.ReplaceAll(s, "TESTING KEY", "PRIVATE KEY") }
diff --git a/src/os/exec/exec_test.go b/src/os/exec/exec_test.go
index 8c623871932f7d..2fa55073f5c19c 100644
--- a/src/os/exec/exec_test.go
+++ b/src/os/exec/exec_test.go
@@ -14,6 +14,7 @@ import (
 	"errors"
 	"flag"
 	"fmt"
+	"internal/goexperiment"
 	"internal/poll"
 	"internal/testenv"
 	"io"
@@ -689,6 +690,14 @@ func TestExtraFiles(t *testing.T) {
 		t.Skipf("skipping test on %q", runtime.GOOS)
 	}
 
+	if goexperiment.OpenSSLCrypto {
+		// OpenSSL default behavior is to maintain open FDs to any
+		// random devices that get used by the random number library.
+		// Since those FDs are not marked FD_CLOEXEC or O_CLOEXEC,
+		// they also get inherited by children.
+		t.Skip("skipping test because test was run with OpenSSLCrypto")
+	}
+
 	// Force network usage, to verify the epoll (or whatever) fd
 	// doesn't leak to the child,
 	ln, err := net.Listen("tcp", "127.0.0.1:0")
diff --git a/src/runtime/pprof/vminfo_darwin_test.go b/src/runtime/pprof/vminfo_darwin_test.go
index 6d375c5d53368a..39154b000ddc67 100644
--- a/src/runtime/pprof/vminfo_darwin_test.go
+++ b/src/runtime/pprof/vminfo_darwin_test.go
@@ -11,6 +11,7 @@ import (
 	"bytes"
 	"fmt"
 	"internal/abi"
+	"internal/goexperiment"
 	"internal/testenv"
 	"os"
 	"os/exec"
@@ -21,6 +22,11 @@ import (
 )
 
 func TestVMInfo(t *testing.T) {
+	if goexperiment.DarwinCrypto {
+		// Fails on macOS when using system crypto.
+		// https://github.com/microsoft/go/issues/1466
+		t.Skip("skipping on Darwin")
+	}
 	var begin, end, offset uint64
 	var filename string
 	first := true
