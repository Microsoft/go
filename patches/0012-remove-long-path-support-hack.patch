From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: qmuntal <qmuntaldiaz@microsoft.com>
Date: Wed, 3 Apr 2024 14:27:11 +0200
Subject: [PATCH] remove long path support hack

Upstream Go tricks Windows into enabling long path support by setting an
undocumented flag in the PEB. The Microsoft Go fork can't use undocumented
APIs, so this commit removes the hack.

There is no documented way to enable long path support from within the
process, so this this is a breaking change for the Microsoft Go fork.
Note that the Go standard library makes a best effort to support long
paths by using the `\\?\` prefix when possible, so this change should
only affect long relative paths, which can't be used with the `\\?\`.

---
 src/runtime/os_windows.go | 52 +--------------------------------------
 1 file changed, 1 insertion(+), 51 deletions(-)

diff --git a/src/runtime/os_windows.go b/src/runtime/os_windows.go
index 766b087c18dd02..4cb57232ed4a03 100644
--- a/src/runtime/os_windows.go
+++ b/src/runtime/os_windows.go
@@ -134,7 +134,6 @@ var (
 	// links wrong printf function to cgo executable (see issue
 	// 12030 for details).
 	_NtWaitForSingleObject stdFunction
-	_RtlGetCurrentPeb      stdFunction
 	_RtlGetVersion         stdFunction
 
 	// These are from non-kernel32.dll, so we prefer to LoadLibraryEx them.
@@ -260,7 +259,6 @@ func loadOptionalSyscalls() {
 		throw("ntdll.dll not found")
 	}
 	_NtWaitForSingleObject = windowsFindfunc(n32, []byte("NtWaitForSingleObject\000"))
-	_RtlGetCurrentPeb = windowsFindfunc(n32, []byte("RtlGetCurrentPeb\000"))
 	_RtlGetVersion = windowsFindfunc(n32, []byte("RtlGetVersion\000"))
 
 	if !haveCputicksAsm {
@@ -460,55 +458,7 @@ var longFileName [(_MAX_PATH+1)*2 + 1]byte
 // canUseLongPaths is set to true, and later when called, os.fixLongPath
 // returns early without doing work.
 func initLongPathSupport() {
-	const (
-		IsLongPathAwareProcess = 0x80
-		PebBitFieldOffset      = 3
-		OPEN_EXISTING          = 3
-		ERROR_PATH_NOT_FOUND   = 3
-	)
-
-	// Check that we're â‰¥ 10.0.15063.
-	info := _OSVERSIONINFOW{}
-	info.osVersionInfoSize = uint32(unsafe.Sizeof(info))
-	stdcall1(_RtlGetVersion, uintptr(unsafe.Pointer(&info)))
-	if info.majorVersion < 10 || (info.majorVersion == 10 && info.minorVersion == 0 && info.buildNumber < 15063) {
-		return
-	}
-
-	// Set the IsLongPathAwareProcess flag of the PEB's bit field.
-	bitField := (*byte)(unsafe.Pointer(stdcall0(_RtlGetCurrentPeb) + PebBitFieldOffset))
-	originalBitField := *bitField
-	*bitField |= IsLongPathAwareProcess
-
-	// Check that this actually has an effect, by constructing a large file
-	// path and seeing whether we get ERROR_PATH_NOT_FOUND, rather than
-	// some other error, which would indicate the path is too long, and
-	// hence long path support is not successful. This whole section is NOT
-	// strictly necessary, but is a nice validity check for the near to
-	// medium term, when this functionality is still relatively new in
-	// Windows.
-	getRandomData(longFileName[len(longFileName)-33 : len(longFileName)-1])
-	start := copy(longFileName[:], sysDirectory[:sysDirectoryLen])
-	const dig = "0123456789abcdef"
-	for i := 0; i < 32; i++ {
-		longFileName[start+i*2] = dig[longFileName[len(longFileName)-33+i]>>4]
-		longFileName[start+i*2+1] = dig[longFileName[len(longFileName)-33+i]&0xf]
-	}
-	start += 64
-	for i := start; i < len(longFileName)-1; i++ {
-		longFileName[i] = 'A'
-	}
-	stdcall7(_CreateFileA, uintptr(unsafe.Pointer(&longFileName[0])), 0, 0, 0, OPEN_EXISTING, 0, 0)
-	// The ERROR_PATH_NOT_FOUND error value is distinct from
-	// ERROR_FILE_NOT_FOUND or ERROR_INVALID_NAME, the latter of which we
-	// expect here due to the final component being too long.
-	if getlasterror() == ERROR_PATH_NOT_FOUND {
-		*bitField = originalBitField
-		println("runtime: warning: IsLongPathAwareProcess failed to enable long paths; proceeding in fixup mode")
-		return
-	}
-
-	canUseLongPaths = true
+	canUseLongPaths = false
 }
 
 func osinit() {
