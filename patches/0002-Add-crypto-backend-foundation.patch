From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: qmuntal <qmuntaldiaz@microsoft.com>
Date: Thu, 30 Jun 2022 10:03:03 +0200
Subject: [PATCH] Add crypto backend foundation

---
 src/crypto/aes/cipher.go                     |   2 +-
 src/crypto/aes/cipher_asm.go                 |   2 +-
 src/crypto/boring/boring.go                  |   2 +-
 src/crypto/des/cipher.go                     |   7 +
 src/crypto/ecdh/ecdh.go                      |   2 +-
 src/crypto/ecdh/nist.go                      |   2 +-
 src/crypto/ecdsa/boring.go                   |   4 +-
 src/crypto/ecdsa/ecdsa.go                    |   4 +-
 src/crypto/ecdsa/notboring.go                |   2 +-
 src/crypto/ed25519/ed25519_test.go           |   2 +-
 src/crypto/hmac/hmac.go                      |   2 +-
 src/crypto/hmac/hmac_test.go                 |   2 +-
 src/crypto/internal/backend/backend_test.go  |  30 ++++
 src/crypto/internal/backend/bbig/big.go      |  17 +++
 src/crypto/internal/backend/common.go        |  78 ++++++++++
 src/crypto/internal/backend/isrequirefips.go |   9 ++
 src/crypto/internal/backend/nobackend.go     | 145 +++++++++++++++++++
 src/crypto/internal/backend/norequirefips.go |   9 ++
 src/crypto/internal/backend/stub.s           |  10 ++
 src/crypto/md5/md5.go                        |   7 +
 src/crypto/md5/md5_test.go                   |   4 +
 src/crypto/rand/rand_unix.go                 |   2 +-
 src/crypto/rsa/boring.go                     |   4 +-
 src/crypto/rsa/notboring.go                  |   2 +-
 src/crypto/rsa/pkcs1v15.go                   |   2 +-
 src/crypto/rsa/pss.go                        |   2 +-
 src/crypto/rsa/rsa.go                        |   4 +-
 src/crypto/rsa/rsa_test.go                   |   2 +-
 src/crypto/sha1/sha1.go                      |   2 +-
 src/crypto/sha1/sha1_test.go                 |   2 +-
 src/crypto/sha256/sha256.go                  |   2 +-
 src/crypto/sha256/sha256_test.go             |   2 +-
 src/crypto/sha512/sha512.go                  |   2 +-
 src/crypto/sha512/sha512_test.go             |   2 +-
 src/crypto/tls/cipher_suites.go              |   2 +-
 src/crypto/tls/handshake_client.go           |  25 +++-
 src/crypto/tls/handshake_server.go           |  25 +++-
 src/crypto/tls/key_schedule.go               |  18 ++-
 src/crypto/tls/prf.go                        |  77 +++++++---
 src/crypto/tls/prf_test.go                   |  12 +-
 src/go/build/deps_test.go                    |   2 +
 src/runtime/runtime_boring.go                |   5 +
 42 files changed, 473 insertions(+), 65 deletions(-)
 create mode 100644 src/crypto/internal/backend/backend_test.go
 create mode 100644 src/crypto/internal/backend/bbig/big.go
 create mode 100644 src/crypto/internal/backend/common.go
 create mode 100644 src/crypto/internal/backend/isrequirefips.go
 create mode 100644 src/crypto/internal/backend/nobackend.go
 create mode 100644 src/crypto/internal/backend/norequirefips.go
 create mode 100644 src/crypto/internal/backend/stub.s

diff --git a/src/crypto/aes/cipher.go b/src/crypto/aes/cipher.go
index 183c1697c867b2..64855f153f1ea7 100644
--- a/src/crypto/aes/cipher.go
+++ b/src/crypto/aes/cipher.go
@@ -7,7 +7,7 @@ package aes
 import (
 	"crypto/cipher"
 	"crypto/internal/alias"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"strconv"
 )
 
diff --git a/src/crypto/aes/cipher_asm.go b/src/crypto/aes/cipher_asm.go
index 90031c5e2c58e6..e80e82c82bd2a1 100644
--- a/src/crypto/aes/cipher_asm.go
+++ b/src/crypto/aes/cipher_asm.go
@@ -9,7 +9,7 @@ package aes
 import (
 	"crypto/cipher"
 	"crypto/internal/alias"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"internal/cpu"
 	"internal/goarch"
 )
diff --git a/src/crypto/boring/boring.go b/src/crypto/boring/boring.go
index 097c37e343fdb8..1cf43edba40359 100644
--- a/src/crypto/boring/boring.go
+++ b/src/crypto/boring/boring.go
@@ -13,7 +13,7 @@
 // is satisfied, so that applications can tag files that use this package.
 package boring
 
-import "crypto/internal/boring"
+import boring "crypto/internal/backend"
 
 // Enabled reports whether BoringCrypto handles supported crypto operations.
 func Enabled() bool {
diff --git a/src/crypto/des/cipher.go b/src/crypto/des/cipher.go
index 699e5177aef5d5..7e9c2a74adf74b 100644
--- a/src/crypto/des/cipher.go
+++ b/src/crypto/des/cipher.go
@@ -7,6 +7,7 @@ package des
 import (
 	"crypto/cipher"
 	"crypto/internal/alias"
+	boring "crypto/internal/backend"
 	"encoding/binary"
 	"strconv"
 )
@@ -30,6 +31,9 @@ func NewCipher(key []byte) (cipher.Block, error) {
 	if len(key) != 8 {
 		return nil, KeySizeError(len(key))
 	}
+	if boring.Enabled && boring.SupportsDESCipher() {
+		return boring.NewDESCipher(key)
+	}
 
 	c := new(desCipher)
 	c.generateSubkeys(key)
@@ -74,6 +78,9 @@ func NewTripleDESCipher(key []byte) (cipher.Block, error) {
 	if len(key) != 24 {
 		return nil, KeySizeError(len(key))
 	}
+	if boring.Enabled && boring.SupportsTripleDESCipher() {
+		return boring.NewTripleDESCipher(key)
+	}
 
 	c := new(tripleDESCipher)
 	c.cipher1.generateSubkeys(key[:8])
diff --git a/src/crypto/ecdh/ecdh.go b/src/crypto/ecdh/ecdh.go
index b21b5697d0e37f..5e373cd27b350f 100644
--- a/src/crypto/ecdh/ecdh.go
+++ b/src/crypto/ecdh/ecdh.go
@@ -8,7 +8,7 @@ package ecdh
 
 import (
 	"crypto"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/subtle"
 	"errors"
 	"io"
diff --git a/src/crypto/ecdh/nist.go b/src/crypto/ecdh/nist.go
index 01354fa2cf0af2..1d198df6e382d4 100644
--- a/src/crypto/ecdh/nist.go
+++ b/src/crypto/ecdh/nist.go
@@ -5,7 +5,7 @@
 package ecdh
 
 import (
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/nistec"
 	"crypto/internal/randutil"
 	"encoding/binary"
diff --git a/src/crypto/ecdsa/boring.go b/src/crypto/ecdsa/boring.go
index 275c60b4de49eb..61e70f981db4eb 100644
--- a/src/crypto/ecdsa/boring.go
+++ b/src/crypto/ecdsa/boring.go
@@ -7,8 +7,8 @@
 package ecdsa
 
 import (
-	"crypto/internal/boring"
-	"crypto/internal/boring/bbig"
+	boring "crypto/internal/backend"
+	"crypto/internal/backend/bbig"
 	"crypto/internal/boring/bcache"
 	"math/big"
 )
diff --git a/src/crypto/ecdsa/ecdsa.go b/src/crypto/ecdsa/ecdsa.go
index e1503779ae421c..e8f8b85fdac62e 100644
--- a/src/crypto/ecdsa/ecdsa.go
+++ b/src/crypto/ecdsa/ecdsa.go
@@ -26,9 +26,9 @@ import (
 	"crypto/cipher"
 	"crypto/ecdh"
 	"crypto/elliptic"
+	boring "crypto/internal/backend"
+	"crypto/internal/backend/bbig"
 	"crypto/internal/bigmod"
-	"crypto/internal/boring"
-	"crypto/internal/boring/bbig"
 	"crypto/internal/nistec"
 	"crypto/internal/randutil"
 	"crypto/sha512"
diff --git a/src/crypto/ecdsa/notboring.go b/src/crypto/ecdsa/notboring.go
index 039bd82ed21f9f..19188518e85e65 100644
--- a/src/crypto/ecdsa/notboring.go
+++ b/src/crypto/ecdsa/notboring.go
@@ -6,7 +6,7 @@
 
 package ecdsa
 
-import "crypto/internal/boring"
+import boring "crypto/internal/backend"
 
 func boringPublicKey(*PublicKey) (*boring.PublicKeyECDSA, error) {
 	panic("boringcrypto: not available")
diff --git a/src/crypto/ed25519/ed25519_test.go b/src/crypto/ed25519/ed25519_test.go
index 47c8698e2a5945..02eff207ae365a 100644
--- a/src/crypto/ed25519/ed25519_test.go
+++ b/src/crypto/ed25519/ed25519_test.go
@@ -9,7 +9,7 @@ import (
 	"bytes"
 	"compress/gzip"
 	"crypto"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/rand"
 	"crypto/sha512"
 	"encoding/hex"
diff --git a/src/crypto/hmac/hmac.go b/src/crypto/hmac/hmac.go
index 35b9d5a17aa545..d6dc0244f7eba8 100644
--- a/src/crypto/hmac/hmac.go
+++ b/src/crypto/hmac/hmac.go
@@ -22,7 +22,7 @@ timing side-channels:
 package hmac
 
 import (
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/subtle"
 	"hash"
 )
diff --git a/src/crypto/hmac/hmac_test.go b/src/crypto/hmac/hmac_test.go
index 55415abf020799..904925377bba44 100644
--- a/src/crypto/hmac/hmac_test.go
+++ b/src/crypto/hmac/hmac_test.go
@@ -6,7 +6,7 @@ package hmac
 
 import (
 	"bytes"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/md5"
 	"crypto/sha1"
 	"crypto/sha256"
diff --git a/src/crypto/internal/backend/backend_test.go b/src/crypto/internal/backend/backend_test.go
new file mode 100644
index 00000000000000..c2c06d3bff8c74
--- /dev/null
+++ b/src/crypto/internal/backend/backend_test.go
@@ -0,0 +1,30 @@
+// Copyright 2017 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package backend
+
+import (
+	"testing"
+)
+
+// Test that Unreachable panics.
+func TestUnreachable(t *testing.T) {
+	defer func() {
+		if Enabled {
+			if err := recover(); err == nil {
+				t.Fatal("expected Unreachable to panic")
+			}
+		} else {
+			if err := recover(); err != nil {
+				t.Fatalf("expected Unreachable to be a no-op")
+			}
+		}
+	}()
+	Unreachable()
+}
+
+// Test that UnreachableExceptTests does not panic (this is a test).
+func TestUnreachableExceptTests(t *testing.T) {
+	UnreachableExceptTests()
+}
diff --git a/src/crypto/internal/backend/bbig/big.go b/src/crypto/internal/backend/bbig/big.go
new file mode 100644
index 00000000000000..85bd3ed083f5b2
--- /dev/null
+++ b/src/crypto/internal/backend/bbig/big.go
@@ -0,0 +1,17 @@
+// Copyright 2022 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build !boringcrypto
+
+package bbig
+
+import "math/big"
+
+func Enc(b *big.Int) []uint {
+	return nil
+}
+
+func Dec(b []uint) *big.Int {
+	return nil
+}
diff --git a/src/crypto/internal/backend/common.go b/src/crypto/internal/backend/common.go
new file mode 100644
index 00000000000000..efdd080a1b7708
--- /dev/null
+++ b/src/crypto/internal/backend/common.go
@@ -0,0 +1,78 @@
+// Copyright 2022 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package backend
+
+import (
+	"crypto/internal/boring/sig"
+	"runtime"
+	"syscall"
+)
+
+func init() {
+	if v, r, ok := envGoFIPS(); ok && v == "1" {
+		if !Enabled {
+			if runtime.GOOS != "linux" && runtime.GOOS != "windows" {
+				panic("FIPS mode requested (" + r + ") but no crypto backend is supported on " + runtime.GOOS)
+			}
+			panic("FIPS mode requested (" + r + ") but no supported crypto backend is enabled")
+		}
+	}
+}
+
+func envGoFIPS() (value string, reason string, ok bool) {
+	// TODO: Decide which environment variable to use.
+	// See https://github.com/microsoft/go/issues/397.
+	var varName string
+	if value, ok = syscall.Getenv("GOFIPS"); ok {
+		varName = "GOFIPS"
+	} else if value, ok = syscall.Getenv("GOLANG_FIPS"); ok {
+		varName = "GOLANG_FIPS"
+	}
+	if isRequireFIPS {
+		if ok && value != "1" {
+			panic("the 'requirefips' build tag is enabled, but it conflicts " +
+				"with the detected env variable " +
+				varName + "=" + value +
+				" which would disable FIPS mode")
+		}
+		return "1", "requirefips tag set", true
+	}
+	if ok {
+		return value, "environment variable " + varName + "=1", true
+	}
+	return "", "", false
+}
+
+// Unreachable marks code that should be unreachable
+// when backend is in use.
+func Unreachable() {
+	if Enabled {
+		panic("cryptobackend: invalid code execution")
+	} else {
+		// Code that's unreachable is exactly the code
+		// we want to detect for reporting standard Go crypto.
+		sig.StandardCrypto()
+	}
+}
+
+// Provided by runtime.crypto_backend_runtime_arg0 to avoid os import.
+func runtime_arg0() string
+
+func hasSuffix(s, t string) bool {
+	return len(s) > len(t) && s[len(s)-len(t):] == t
+}
+
+// UnreachableExceptTests marks code that should be unreachable
+// when backend is in use. It panics.
+func UnreachableExceptTests() {
+	if Enabled {
+		name := runtime_arg0()
+		// If ran on Windows we'd need to allow _test.exe and .test.exe as well.
+		if !hasSuffix(name, "_test") && !hasSuffix(name, ".test") {
+			println("cryptobackend: unexpected code execution in", name)
+			panic("cryptobackend: invalid code execution")
+		}
+	}
+}
diff --git a/src/crypto/internal/backend/isrequirefips.go b/src/crypto/internal/backend/isrequirefips.go
new file mode 100644
index 00000000000000..e5d7570d6d4363
--- /dev/null
+++ b/src/crypto/internal/backend/isrequirefips.go
@@ -0,0 +1,9 @@
+// Copyright 2022 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build requirefips
+
+package backend
+
+const isRequireFIPS = true
diff --git a/src/crypto/internal/backend/nobackend.go b/src/crypto/internal/backend/nobackend.go
new file mode 100644
index 00000000000000..75eb22290bcc92
--- /dev/null
+++ b/src/crypto/internal/backend/nobackend.go
@@ -0,0 +1,143 @@
+// Copyright 2017 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Do not edit the build constraint by hand. It is generated by "backendgen.go".
+
+//go:build ignore
+
+package backend
+
+import (
+	"crypto"
+	"crypto/cipher"
+	"hash"
+	"io"
+)
+
+const Enabled = false
+
+type BigInt = []uint
+
+type randReader int
+
+func (randReader) Read(b []byte) (int, error) { panic("cryptobackend: not available") }
+
+const RandReader = randReader(0)
+
+func SupportsHash(h crypto.Hash) bool { panic("cryptobackend: not available") }
+
+func NewMD5() hash.Hash    { panic("cryptobackend: not available") }
+func NewSHA1() hash.Hash   { panic("cryptobackend: not available") }
+func NewSHA224() hash.Hash { panic("cryptobackend: not available") }
+func NewSHA256() hash.Hash { panic("cryptobackend: not available") }
+func NewSHA384() hash.Hash { panic("cryptobackend: not available") }
+func NewSHA512() hash.Hash { panic("cryptobackend: not available") }
+
+func MD5(p []byte) (sum [16]byte)    { panic("cryptobackend: not available") }
+func SHA1(p []byte) (sum [20]byte)   { panic("cryptobackend: not available") }
+func SHA224(p []byte) (sum [28]byte) { panic("cryptobackend: not available") }
+func SHA256(p []byte) (sum [32]byte) { panic("cryptobackend: not available") }
+func SHA384(p []byte) (sum [48]byte) { panic("cryptobackend: not available") }
+func SHA512(p []byte) (sum [64]byte) { panic("cryptobackend: not available") }
+
+func NewHMAC(h func() hash.Hash, key []byte) hash.Hash { panic("cryptobackend: not available") }
+
+func NewAESCipher(key []byte) (cipher.Block, error) { panic("cryptobackend: not available") }
+func NewGCMTLS(c cipher.Block) (cipher.AEAD, error) { panic("cryptobackend: not available") }
+
+type PublicKeyECDSA struct{ _ int }
+type PrivateKeyECDSA struct{ _ int }
+
+func GenerateKeyECDSA(curve string) (X, Y, D BigInt, err error) {
+	panic("cryptobackend: not available")
+}
+func NewPrivateKeyECDSA(curve string, X, Y, D BigInt) (*PrivateKeyECDSA, error) {
+	panic("cryptobackend: not available")
+}
+func NewPublicKeyECDSA(curve string, X, Y BigInt) (*PublicKeyECDSA, error) {
+	panic("cryptobackend: not available")
+}
+func SignMarshalECDSA(priv *PrivateKeyECDSA, hash []byte) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+func VerifyECDSA(pub *PublicKeyECDSA, hash []byte, sig []byte) bool {
+	panic("cryptobackend: not available")
+}
+
+type PublicKeyRSA struct{ _ int }
+type PrivateKeyRSA struct{ _ int }
+
+func DecryptRSAOAEP(h, mgfHash hash.Hash, priv *PrivateKeyRSA, ciphertext, label []byte) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+func DecryptRSAPKCS1(priv *PrivateKeyRSA, ciphertext []byte) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+func DecryptRSANoPadding(priv *PrivateKeyRSA, ciphertext []byte) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+func EncryptRSAOAEP(h, mgfHash hash.Hash, pub *PublicKeyRSA, msg, label []byte) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+func EncryptRSAPKCS1(pub *PublicKeyRSA, msg []byte) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+func EncryptRSANoPadding(pub *PublicKeyRSA, msg []byte) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+func GenerateKeyRSA(bits int) (N, E, D, P, Q, Dp, Dq, Qinv BigInt, err error) {
+	panic("cryptobackend: not available")
+}
+func NewPrivateKeyRSA(N, E, D, P, Q, Dp, Dq, Qinv BigInt) (*PrivateKeyRSA, error) {
+	panic("cryptobackend: not available")
+}
+func NewPublicKeyRSA(N, E BigInt) (*PublicKeyRSA, error) {
+	panic("cryptobackend: not available")
+}
+func SignRSAPKCS1v15(priv *PrivateKeyRSA, h crypto.Hash, hashed []byte) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+func SignRSAPSS(priv *PrivateKeyRSA, h crypto.Hash, hashed []byte, saltLen int) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+func VerifyRSAPKCS1v15(pub *PublicKeyRSA, h crypto.Hash, hashed, sig []byte) error {
+	panic("cryptobackend: not available")
+}
+func VerifyRSAPSS(pub *PublicKeyRSA, h crypto.Hash, hashed, sig []byte, saltLen int) error {
+	panic("cryptobackend: not available")
+}
+
+type PublicKeyECDH struct{}
+type PrivateKeyECDH struct{}
+
+func ECDH(*PrivateKeyECDH, *PublicKeyECDH) ([]byte, error)    { panic("cryptobackend: not available") }
+func GenerateKeyECDH(string) (*PrivateKeyECDH, []byte, error) { panic("cryptobackend: not available") }
+func NewPrivateKeyECDH(string, []byte) (*PrivateKeyECDH, error) {
+	panic("cryptobackend: not available")
+}
+func NewPublicKeyECDH(string, []byte) (*PublicKeyECDH, error) { panic("cryptobackend: not available") }
+func (*PublicKeyECDH) Bytes() []byte                          { panic("cryptobackend: not available") }
+func (*PrivateKeyECDH) PublicKey() (*PublicKeyECDH, error)    { panic("cryptobackend: not available") }
+
+func SupportsHKDF() bool { panic("cryptobackend: not available") }
+
+func ExpandHKDF(h func() hash.Hash, pseudorandomKey, info []byte) (io.Reader, error) {
+	panic("cryptobackend: not available")
+}
+
+func ExtractHKDF(h func() hash.Hash, secret, salt []byte) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+
+func SupportsTLS1PRF() bool { panic("cryptobackend: not available") }
+
+func TLS1PRF(result, secret, label, seed []byte, h func() hash.Hash) error {
+	panic("cryptobackend: not available")
+}
+
+func SupportsDESCipher() bool { panic("cryptobackend: not available") }
+
+func SupportsTripleDESCipher() bool { panic("cryptobackend: not available") }
+
+func NewDESCipher(key []byte) (cipher.Block, error) { panic("cryptobackend: not available") }
+
+func NewTripleDESCipher(key []byte) (cipher.Block, error) { panic("cryptobackend: not available") }
diff --git a/src/crypto/internal/backend/norequirefips.go b/src/crypto/internal/backend/norequirefips.go
new file mode 100644
index 00000000000000..26bfb5f6a643f3
--- /dev/null
+++ b/src/crypto/internal/backend/norequirefips.go
@@ -0,0 +1,9 @@
+// Copyright 2022 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build !requirefips
+
+package backend
+
+const isRequireFIPS = false
diff --git a/src/crypto/internal/backend/stub.s b/src/crypto/internal/backend/stub.s
new file mode 100644
index 00000000000000..5e4b436554d44d
--- /dev/null
+++ b/src/crypto/internal/backend/stub.s
@@ -0,0 +1,10 @@
+// Copyright 2017 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// runtime_arg0 is declared in common.go without a body.
+// It's provided by package runtime,
+// but the go command doesn't know that.
+// Having this assembly file keeps the go command
+// from complaining about the missing body
+// (because the implementation might be here).
diff --git a/src/crypto/md5/md5.go b/src/crypto/md5/md5.go
index ccee4ea3a9914f..206249f5bf261e 100644
--- a/src/crypto/md5/md5.go
+++ b/src/crypto/md5/md5.go
@@ -12,6 +12,7 @@ package md5
 
 import (
 	"crypto"
+	boring "crypto/internal/backend"
 	"encoding/binary"
 	"errors"
 	"hash"
@@ -99,6 +100,9 @@ func consumeUint32(b []byte) ([]byte, uint32) {
 // implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to
 // marshal and unmarshal the internal state of the hash.
 func New() hash.Hash {
+	if boring.Enabled && boring.SupportsHash(crypto.MD5) {
+		return boring.NewMD5()
+	}
 	d := new(digest)
 	d.Reset()
 	return d
@@ -176,6 +180,9 @@ func (d *digest) checkSum() [Size]byte {
 
 // Sum returns the MD5 checksum of the data.
 func Sum(data []byte) [Size]byte {
+	if boring.Enabled && boring.SupportsHash(crypto.MD5) {
+		return boring.MD5(data)
+	}
 	var d digest
 	d.Reset()
 	d.Write(data)
diff --git a/src/crypto/md5/md5_test.go b/src/crypto/md5/md5_test.go
index 851e7fb10d42f5..f9d1037c9b82b9 100644
--- a/src/crypto/md5/md5_test.go
+++ b/src/crypto/md5/md5_test.go
@@ -6,6 +6,7 @@ package md5
 
 import (
 	"bytes"
+	boring "crypto/internal/backend"
 	"crypto/rand"
 	"encoding"
 	"fmt"
@@ -144,6 +145,9 @@ func TestLarge(t *testing.T) {
 
 // Tests that blockGeneric (pure Go) and block (in assembly for amd64, 386, arm) match.
 func TestBlockGeneric(t *testing.T) {
+	if boring.Enabled {
+		t.Skip("digest is not used when boring.Enabled is set")
+	}
 	gen, asm := New().(*digest), New().(*digest)
 	buf := make([]byte, BlockSize*20) // arbitrary factor
 	rand.Read(buf)
diff --git a/src/crypto/rand/rand_unix.go b/src/crypto/rand/rand_unix.go
index 40fce36314adfa..1d6231ae91d5ae 100644
--- a/src/crypto/rand/rand_unix.go
+++ b/src/crypto/rand/rand_unix.go
@@ -10,7 +10,7 @@
 package rand
 
 import (
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"errors"
 	"io"
 	"os"
diff --git a/src/crypto/rsa/boring.go b/src/crypto/rsa/boring.go
index b9f9d3154f2589..ecb43aaf264743 100644
--- a/src/crypto/rsa/boring.go
+++ b/src/crypto/rsa/boring.go
@@ -7,8 +7,8 @@
 package rsa
 
 import (
-	"crypto/internal/boring"
-	"crypto/internal/boring/bbig"
+	boring "crypto/internal/backend"
+	"crypto/internal/backend/bbig"
 	"crypto/internal/boring/bcache"
 	"math/big"
 )
diff --git a/src/crypto/rsa/notboring.go b/src/crypto/rsa/notboring.go
index 2abc0436405f8a..34c22c8fbba7da 100644
--- a/src/crypto/rsa/notboring.go
+++ b/src/crypto/rsa/notboring.go
@@ -6,7 +6,7 @@
 
 package rsa
 
-import "crypto/internal/boring"
+import boring "crypto/internal/backend"
 
 func boringPublicKey(*PublicKey) (*boring.PublicKeyRSA, error) {
 	panic("boringcrypto: not available")
diff --git a/src/crypto/rsa/pkcs1v15.go b/src/crypto/rsa/pkcs1v15.go
index 55fea1ab93d29a..05357064930a92 100644
--- a/src/crypto/rsa/pkcs1v15.go
+++ b/src/crypto/rsa/pkcs1v15.go
@@ -6,7 +6,7 @@ package rsa
 
 import (
 	"crypto"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/randutil"
 	"crypto/subtle"
 	"errors"
diff --git a/src/crypto/rsa/pss.go b/src/crypto/rsa/pss.go
index 3a377cc9dbbddb..1096f5fbbb8846 100644
--- a/src/crypto/rsa/pss.go
+++ b/src/crypto/rsa/pss.go
@@ -9,7 +9,7 @@ package rsa
 import (
 	"bytes"
 	"crypto"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"errors"
 	"hash"
 	"io"
diff --git a/src/crypto/rsa/rsa.go b/src/crypto/rsa/rsa.go
index f0aef1f542bec9..7f44522c7fe8c0 100644
--- a/src/crypto/rsa/rsa.go
+++ b/src/crypto/rsa/rsa.go
@@ -27,9 +27,9 @@ package rsa
 
 import (
 	"crypto"
+	boring "crypto/internal/backend"
+	"crypto/internal/backend/bbig"
 	"crypto/internal/bigmod"
-	"crypto/internal/boring"
-	"crypto/internal/boring/bbig"
 	"crypto/internal/randutil"
 	"crypto/rand"
 	"crypto/subtle"
diff --git a/src/crypto/rsa/rsa_test.go b/src/crypto/rsa/rsa_test.go
index 3278a7ff305766..95f4b8e98d2fb0 100644
--- a/src/crypto/rsa/rsa_test.go
+++ b/src/crypto/rsa/rsa_test.go
@@ -8,7 +8,7 @@ import (
 	"bufio"
 	"bytes"
 	"crypto"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/rand"
 	. "crypto/rsa"
 	"crypto/sha1"
diff --git a/src/crypto/sha1/sha1.go b/src/crypto/sha1/sha1.go
index bde642d905d70b..e73c1a6560a5fd 100644
--- a/src/crypto/sha1/sha1.go
+++ b/src/crypto/sha1/sha1.go
@@ -10,7 +10,7 @@ package sha1
 
 import (
 	"crypto"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"encoding/binary"
 	"errors"
 	"hash"
diff --git a/src/crypto/sha1/sha1_test.go b/src/crypto/sha1/sha1_test.go
index 85ed12609154ff..bc169888786321 100644
--- a/src/crypto/sha1/sha1_test.go
+++ b/src/crypto/sha1/sha1_test.go
@@ -8,7 +8,7 @@ package sha1
 
 import (
 	"bytes"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/rand"
 	"encoding"
 	"fmt"
diff --git a/src/crypto/sha256/sha256.go b/src/crypto/sha256/sha256.go
index 2deafbc9fcd0f9..b6fd0c3aab5100 100644
--- a/src/crypto/sha256/sha256.go
+++ b/src/crypto/sha256/sha256.go
@@ -8,7 +8,7 @@ package sha256
 
 import (
 	"crypto"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"encoding/binary"
 	"errors"
 	"hash"
diff --git a/src/crypto/sha256/sha256_test.go b/src/crypto/sha256/sha256_test.go
index 7304678346b32e..7437655badee23 100644
--- a/src/crypto/sha256/sha256_test.go
+++ b/src/crypto/sha256/sha256_test.go
@@ -8,7 +8,7 @@ package sha256
 
 import (
 	"bytes"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/rand"
 	"encoding"
 	"fmt"
diff --git a/src/crypto/sha512/sha512.go b/src/crypto/sha512/sha512.go
index 9ae1b3aae2f013..37a2ae88191ed0 100644
--- a/src/crypto/sha512/sha512.go
+++ b/src/crypto/sha512/sha512.go
@@ -12,7 +12,7 @@ package sha512
 
 import (
 	"crypto"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"encoding/binary"
 	"errors"
 	"hash"
diff --git a/src/crypto/sha512/sha512_test.go b/src/crypto/sha512/sha512_test.go
index 921cdbb7bbd477..2fef7ddae07480 100644
--- a/src/crypto/sha512/sha512_test.go
+++ b/src/crypto/sha512/sha512_test.go
@@ -8,7 +8,7 @@ package sha512
 
 import (
 	"bytes"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/rand"
 	"encoding"
 	"encoding/hex"
diff --git a/src/crypto/tls/cipher_suites.go b/src/crypto/tls/cipher_suites.go
index 589e8b6fafbba3..0a6d665ee3096d 100644
--- a/src/crypto/tls/cipher_suites.go
+++ b/src/crypto/tls/cipher_suites.go
@@ -10,7 +10,7 @@ import (
 	"crypto/cipher"
 	"crypto/des"
 	"crypto/hmac"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/rc4"
 	"crypto/sha1"
 	"crypto/sha256"
diff --git a/src/crypto/tls/handshake_client.go b/src/crypto/tls/handshake_client.go
index 4649f36dea6773..f96b2b28862234 100644
--- a/src/crypto/tls/handshake_client.go
+++ b/src/crypto/tls/handshake_client.go
@@ -653,12 +653,16 @@ func (hs *clientHandshakeState) doFullHandshake() error {
 
 	if hs.serverHello.extendedMasterSecret {
 		c.extMasterSecret = true
-		hs.masterSecret = extMasterFromPreMasterSecret(c.vers, hs.suite, preMasterSecret,
+		hs.masterSecret, err = extMasterFromPreMasterSecret(c.vers, hs.suite, preMasterSecret,
 			hs.finishedHash.Sum())
 	} else {
-		hs.masterSecret = masterFromPreMasterSecret(c.vers, hs.suite, preMasterSecret,
+		hs.masterSecret, err = masterFromPreMasterSecret(c.vers, hs.suite, preMasterSecret,
 			hs.hello.random, hs.serverHello.random)
 	}
+	if err != nil {
+		c.sendAlert(alertInternalError)
+		return err
+	}
 	if err := c.config.writeKeyLog(keyLogLabelTLS12, hs.hello.random, hs.masterSecret); err != nil {
 		c.sendAlert(alertInternalError)
 		return errors.New("tls: failed to write to key log: " + err.Error())
@@ -719,8 +723,12 @@ func (hs *clientHandshakeState) doFullHandshake() error {
 func (hs *clientHandshakeState) establishKeys() error {
 	c := hs.c
 
-	clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV :=
+	clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV, err :=
 		keysFromMasterSecret(c.vers, hs.suite, hs.masterSecret, hs.hello.random, hs.serverHello.random, hs.suite.macLen, hs.suite.keyLen, hs.suite.ivLen)
+	if err != nil {
+		c.sendAlert(alertInternalError)
+		return err
+	}
 	var clientCipher, serverCipher any
 	var clientHash, serverHash hash.Hash
 	if hs.suite.cipher != nil {
@@ -860,7 +868,11 @@ func (hs *clientHandshakeState) readFinished(out []byte) error {
 		return unexpectedMessageError(serverFinished, msg)
 	}
 
-	verify := hs.finishedHash.serverSum(hs.masterSecret)
+	verify, err := hs.finishedHash.serverSum(hs.masterSecret)
+	if err != nil {
+		c.sendAlert(alertHandshakeFailure)
+		return err
+	}
 	if len(verify) != len(serverFinished.verifyData) ||
 		subtle.ConstantTimeCompare(verify, serverFinished.verifyData) != 1 {
 		c.sendAlert(alertHandshakeFailure)
@@ -930,7 +942,10 @@ func (hs *clientHandshakeState) sendFinished(out []byte) error {
 	}
 
 	finished := new(finishedMsg)
-	finished.verifyData = hs.finishedHash.clientSum(hs.masterSecret)
+	var err error
+	if finished.verifyData, err = hs.finishedHash.clientSum(hs.masterSecret); err != nil {
+		return err
+	}
 	if _, err := hs.c.writeHandshakeRecord(finished, &hs.finishedHash); err != nil {
 		return err
 	}
diff --git a/src/crypto/tls/handshake_server.go b/src/crypto/tls/handshake_server.go
index 996b23b1f52341..0c645ead0adba3 100644
--- a/src/crypto/tls/handshake_server.go
+++ b/src/crypto/tls/handshake_server.go
@@ -668,12 +668,16 @@ func (hs *serverHandshakeState) doFullHandshake() error {
 	}
 	if hs.hello.extendedMasterSecret {
 		c.extMasterSecret = true
-		hs.masterSecret = extMasterFromPreMasterSecret(c.vers, hs.suite, preMasterSecret,
+		hs.masterSecret, err = extMasterFromPreMasterSecret(c.vers, hs.suite, preMasterSecret,
 			hs.finishedHash.Sum())
 	} else {
-		hs.masterSecret = masterFromPreMasterSecret(c.vers, hs.suite, preMasterSecret,
+		hs.masterSecret, err = masterFromPreMasterSecret(c.vers, hs.suite, preMasterSecret,
 			hs.clientHello.random, hs.hello.random)
 	}
+	if err != nil {
+		c.sendAlert(alertInternalError)
+		return err
+	}
 	if err := c.config.writeKeyLog(keyLogLabelTLS12, hs.clientHello.random, hs.masterSecret); err != nil {
 		c.sendAlert(alertInternalError)
 		return err
@@ -737,8 +741,12 @@ func (hs *serverHandshakeState) doFullHandshake() error {
 func (hs *serverHandshakeState) establishKeys() error {
 	c := hs.c
 
-	clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV :=
+	clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV, err :=
 		keysFromMasterSecret(c.vers, hs.suite, hs.masterSecret, hs.clientHello.random, hs.hello.random, hs.suite.macLen, hs.suite.keyLen, hs.suite.ivLen)
+	if err != nil {
+		c.sendAlert(alertInternalError)
+		return err
+	}
 
 	var clientCipher, serverCipher any
 	var clientHash, serverHash hash.Hash
@@ -779,7 +787,11 @@ func (hs *serverHandshakeState) readFinished(out []byte) error {
 		return unexpectedMessageError(clientFinished, msg)
 	}
 
-	verify := hs.finishedHash.clientSum(hs.masterSecret)
+	verify, err := hs.finishedHash.clientSum(hs.masterSecret)
+	if err != nil {
+		c.sendAlert(alertHandshakeFailure)
+		return err
+	}
 	if len(verify) != len(clientFinished.verifyData) ||
 		subtle.ConstantTimeCompare(verify, clientFinished.verifyData) != 1 {
 		c.sendAlert(alertHandshakeFailure)
@@ -843,7 +855,10 @@ func (hs *serverHandshakeState) sendFinished(out []byte) error {
 	}
 
 	finished := new(finishedMsg)
-	finished.verifyData = hs.finishedHash.serverSum(hs.masterSecret)
+	var err error
+	if finished.verifyData, err = hs.finishedHash.serverSum(hs.masterSecret); err != nil {
+		return err
+	}
 	if _, err := hs.c.writeHandshakeRecord(finished, &hs.finishedHash); err != nil {
 		return err
 	}
diff --git a/src/crypto/tls/key_schedule.go b/src/crypto/tls/key_schedule.go
index d7f082c9ee1e04..14a85fbf1bd465 100644
--- a/src/crypto/tls/key_schedule.go
+++ b/src/crypto/tls/key_schedule.go
@@ -59,7 +59,16 @@ func (c *cipherSuiteTLS13) expandLabel(secret []byte, label string, context []by
 		panic(fmt.Errorf("failed to construct HKDF label: %s", err))
 	}
 	out := make([]byte, length)
-	n, err := hkdf.Expand(c.hash.New, secret, hkdfLabelBytes).Read(out)
+	var r io.Reader
+	if boring.Enabled && boring.SupportsHKDF() {
+		r, err = boring.ExpandHKDF(c.hash.New, secret, hkdfLabelBytes)
+		if err != nil {
+			panic(fmt.Errorf("tls: HKDF-Expand-Label invocation failed unexpectedly: %s", err))
+		}
+	} else {
+		r = hkdf.Expand(c.hash.New, secret, hkdfLabelBytes)
+	}
+	n, err := r.Read(out)
 	if err != nil || n != length {
 		panic("tls: HKDF-Expand-Label invocation failed unexpectedly")
 	}
@@ -79,6 +88,13 @@ func (c *cipherSuiteTLS13) extract(newSecret, currentSecret []byte) []byte {
 	if newSecret == nil {
 		newSecret = make([]byte, c.hash.Size())
 	}
+	if boring.Enabled && boring.SupportsHKDF() {
+		prk, err := boring.ExtractHKDF(c.hash.New, newSecret, currentSecret)
+		if err != nil {
+			panic(fmt.Errorf("tls: HKDF-Extract invocation failed unexpectedly: %s", err))
+		}
+		return prk
+	}
 	return hkdf.Extract(c.hash.New, newSecret, currentSecret)
 }
 
diff --git a/src/crypto/tls/prf.go b/src/crypto/tls/prf.go
index 20bac96e86703b..c47391f684dc6f 100644
--- a/src/crypto/tls/prf.go
+++ b/src/crypto/tls/prf.go
@@ -7,6 +7,7 @@ package tls
 import (
 	"crypto"
 	"crypto/hmac"
+	boring "crypto/internal/backend"
 	"crypto/md5"
 	"crypto/sha1"
 	"crypto/sha256"
@@ -45,7 +46,13 @@ func pHash(result, secret, seed []byte, hash func() hash.Hash) {
 }
 
 // prf10 implements the TLS 1.0 pseudo-random function, as defined in RFC 2246, Section 5.
-func prf10(result, secret, label, seed []byte) {
+func prf10(result, secret, label, seed []byte) error {
+	if boring.Enabled && boring.SupportsTLS1PRF() && boring.SupportsHash(crypto.MD5SHA1) {
+		if err := boring.TLS1PRF(result, secret, label, seed, nil); err != nil {
+			return fmt.Errorf("crypto/tls: prf10: %v", err)
+		}
+		return nil
+	}
 	hashSHA1 := sha1.New
 	hashMD5 := md5.New
 
@@ -61,16 +68,24 @@ func prf10(result, secret, label, seed []byte) {
 	for i, b := range result2 {
 		result[i] ^= b
 	}
+	return nil
 }
 
 // prf12 implements the TLS 1.2 pseudo-random function, as defined in RFC 5246, Section 5.
-func prf12(hashFunc func() hash.Hash) func(result, secret, label, seed []byte) {
-	return func(result, secret, label, seed []byte) {
+func prf12(h crypto.Hash, hashFunc func() hash.Hash) func(result, secret, label, seed []byte) error {
+	return func(result, secret, label, seed []byte) error {
+		if boring.Enabled && boring.SupportsTLS1PRF() && boring.SupportsHash(h) {
+			if err := boring.TLS1PRF(result, secret, label, seed, hashFunc); err != nil {
+				return fmt.Errorf("crypto/tls: prf12: %v", err)
+			}
+			return nil
+		}
 		labelAndSeed := make([]byte, len(label)+len(seed))
 		copy(labelAndSeed, label)
 		copy(labelAndSeed[len(label):], seed)
 
 		pHash(result, secret, labelAndSeed, hashFunc)
+		return nil
 	}
 }
 
@@ -85,56 +100,64 @@ var keyExpansionLabel = []byte("key expansion")
 var clientFinishedLabel = []byte("client finished")
 var serverFinishedLabel = []byte("server finished")
 
-func prfAndHashForVersion(version uint16, suite *cipherSuite) (func(result, secret, label, seed []byte), crypto.Hash) {
+func prfAndHashForVersion(version uint16, suite *cipherSuite) (func(result, secret, label, seed []byte) error, crypto.Hash) {
 	switch version {
 	case VersionTLS10, VersionTLS11:
 		return prf10, crypto.Hash(0)
 	case VersionTLS12:
 		if suite.flags&suiteSHA384 != 0 {
-			return prf12(sha512.New384), crypto.SHA384
+			h := crypto.SHA384
+			return prf12(h, sha512.New384), h
 		}
-		return prf12(sha256.New), crypto.SHA256
+		h := crypto.SHA256
+		return prf12(h, sha256.New), h
 	default:
 		panic("unknown version")
 	}
 }
 
-func prfForVersion(version uint16, suite *cipherSuite) func(result, secret, label, seed []byte) {
+func prfForVersion(version uint16, suite *cipherSuite) func(result, secret, label, seed []byte) error {
 	prf, _ := prfAndHashForVersion(version, suite)
 	return prf
 }
 
 // masterFromPreMasterSecret generates the master secret from the pre-master
 // secret. See RFC 5246, Section 8.1.
-func masterFromPreMasterSecret(version uint16, suite *cipherSuite, preMasterSecret, clientRandom, serverRandom []byte) []byte {
+func masterFromPreMasterSecret(version uint16, suite *cipherSuite, preMasterSecret, clientRandom, serverRandom []byte) ([]byte, error) {
 	seed := make([]byte, 0, len(clientRandom)+len(serverRandom))
 	seed = append(seed, clientRandom...)
 	seed = append(seed, serverRandom...)
 
 	masterSecret := make([]byte, masterSecretLength)
-	prfForVersion(version, suite)(masterSecret, preMasterSecret, masterSecretLabel, seed)
-	return masterSecret
+	if err := prfForVersion(version, suite)(masterSecret, preMasterSecret, masterSecretLabel, seed); err != nil {
+		return nil, err
+	}
+	return masterSecret, nil
 }
 
 // extMasterFromPreMasterSecret generates the extended master secret from the
 // pre-master secret. See RFC 7627.
-func extMasterFromPreMasterSecret(version uint16, suite *cipherSuite, preMasterSecret, transcript []byte) []byte {
+func extMasterFromPreMasterSecret(version uint16, suite *cipherSuite, preMasterSecret, transcript []byte) ([]byte, error) {
 	masterSecret := make([]byte, masterSecretLength)
-	prfForVersion(version, suite)(masterSecret, preMasterSecret, extendedMasterSecretLabel, transcript)
-	return masterSecret
+	if err := prfForVersion(version, suite)(masterSecret, preMasterSecret, extendedMasterSecretLabel, transcript); err != nil {
+		return nil, err
+	}
+	return masterSecret, nil
 }
 
 // keysFromMasterSecret generates the connection keys from the master
 // secret, given the lengths of the MAC key, cipher key and IV, as defined in
 // RFC 2246, Section 6.3.
-func keysFromMasterSecret(version uint16, suite *cipherSuite, masterSecret, clientRandom, serverRandom []byte, macLen, keyLen, ivLen int) (clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV []byte) {
+func keysFromMasterSecret(version uint16, suite *cipherSuite, masterSecret, clientRandom, serverRandom []byte, macLen, keyLen, ivLen int) (clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV []byte, err error) {
 	seed := make([]byte, 0, len(serverRandom)+len(clientRandom))
 	seed = append(seed, serverRandom...)
 	seed = append(seed, clientRandom...)
 
 	n := 2*macLen + 2*keyLen + 2*ivLen
 	keyMaterial := make([]byte, n)
-	prfForVersion(version, suite)(keyMaterial, masterSecret, keyExpansionLabel, seed)
+	if err = prfForVersion(version, suite)(keyMaterial, masterSecret, keyExpansionLabel, seed); err != nil {
+		return
+	}
 	clientMAC = keyMaterial[:macLen]
 	keyMaterial = keyMaterial[macLen:]
 	serverMAC = keyMaterial[:macLen]
@@ -177,7 +200,7 @@ type finishedHash struct {
 	buffer []byte
 
 	version uint16
-	prf     func(result, secret, label, seed []byte)
+	prf     func(result, secret, label, seed []byte) error
 }
 
 func (h *finishedHash) Write(msg []byte) (n int, err error) {
@@ -208,18 +231,22 @@ func (h finishedHash) Sum() []byte {
 
 // clientSum returns the contents of the verify_data member of a client's
 // Finished message.
-func (h finishedHash) clientSum(masterSecret []byte) []byte {
+func (h finishedHash) clientSum(masterSecret []byte) ([]byte, error) {
 	out := make([]byte, finishedVerifyLength)
-	h.prf(out, masterSecret, clientFinishedLabel, h.Sum())
-	return out
+	if err := h.prf(out, masterSecret, clientFinishedLabel, h.Sum()); err != nil {
+		return nil, err
+	}
+	return out, nil
 }
 
 // serverSum returns the contents of the verify_data member of a server's
 // Finished message.
-func (h finishedHash) serverSum(masterSecret []byte) []byte {
+func (h finishedHash) serverSum(masterSecret []byte) ([]byte, error) {
 	out := make([]byte, finishedVerifyLength)
-	h.prf(out, masterSecret, serverFinishedLabel, h.Sum())
-	return out
+	if err := h.prf(out, masterSecret, serverFinishedLabel, h.Sum()); err != nil {
+		return nil, err
+	}
+	return out, nil
 }
 
 // hashForClientCertificate returns the handshake messages so far, pre-hashed if
@@ -286,7 +313,11 @@ func ekmFromMasterSecret(version uint16, suite *cipherSuite, masterSecret, clien
 		}
 
 		keyMaterial := make([]byte, length)
-		prfForVersion(version, suite)(keyMaterial, masterSecret, []byte(label), seed)
+		if err := prfForVersion(version, suite)(keyMaterial, masterSecret, []byte(label), seed); err != nil {
+			// Could happen if the seed is too large. The Go implementation doesn't limit the seed size,
+			// as RFC 5705 doesn't specify a limit, but stock OpenSSL restrict it to 1024 and CNG to 256.
+			return nil, err
+		}
 		return keyMaterial, nil
 	}
 }
diff --git a/src/crypto/tls/prf_test.go b/src/crypto/tls/prf_test.go
index 8233985a62bd22..f46d4636557714 100644
--- a/src/crypto/tls/prf_test.go
+++ b/src/crypto/tls/prf_test.go
@@ -51,13 +51,21 @@ func TestKeysFromPreMasterSecret(t *testing.T) {
 		clientRandom, _ := hex.DecodeString(test.clientRandom)
 		serverRandom, _ := hex.DecodeString(test.serverRandom)
 
-		masterSecret := masterFromPreMasterSecret(test.version, test.suite, in, clientRandom, serverRandom)
+		masterSecret, err := masterFromPreMasterSecret(test.version, test.suite, in, clientRandom, serverRandom)
+		if err != nil {
+			t.Errorf("#%d: masterFromPreMasterSecret failed: %s", i, err)
+			continue
+		}
 		if s := hex.EncodeToString(masterSecret); s != test.masterSecret {
 			t.Errorf("#%d: bad master secret %s, want %s", i, s, test.masterSecret)
 			continue
 		}
 
-		clientMAC, serverMAC, clientKey, serverKey, _, _ := keysFromMasterSecret(test.version, test.suite, masterSecret, clientRandom, serverRandom, test.macLen, test.keyLen, 0)
+		clientMAC, serverMAC, clientKey, serverKey, _, _, err := keysFromMasterSecret(test.version, test.suite, masterSecret, clientRandom, serverRandom, test.macLen, test.keyLen, 0)
+		if err != nil {
+			t.Errorf("#%d: keysFromMasterSecret failed: %s", i, err)
+			continue
+		}
 		clientMACString := hex.EncodeToString(clientMAC)
 		serverMACString := hex.EncodeToString(serverMAC)
 		clientKeyString := hex.EncodeToString(clientKey)
diff --git a/src/go/build/deps_test.go b/src/go/build/deps_test.go
index 187dff74cfcb54..0fc11c2fb3ae7b 100644
--- a/src/go/build/deps_test.go
+++ b/src/go/build/deps_test.go
@@ -428,6 +428,7 @@ var depsRules = `
 	crypto/cipher,
 	crypto/internal/boring/bcache
 	< crypto/internal/boring
+	< crypto/internal/backend
 	< crypto/boring;
 
 	crypto/internal/alias
@@ -461,6 +462,7 @@ var depsRules = `
 	# CRYPTO-MATH is core bignum-based crypto - no cgo, net; fmt now ok.
 	CRYPTO, FMT, math/big
 	< crypto/internal/boring/bbig
+	< crypto/internal/backend/bbig
 	< crypto/rand
 	< crypto/ed25519
 	< encoding/asn1
diff --git a/src/runtime/runtime_boring.go b/src/runtime/runtime_boring.go
index 5a98b20253181c..9042f2c2795e19 100644
--- a/src/runtime/runtime_boring.go
+++ b/src/runtime/runtime_boring.go
@@ -17,3 +17,8 @@ func boring_runtime_arg0() string {
 
 //go:linkname fipstls_runtime_arg0 crypto/internal/boring/fipstls.runtime_arg0
 func fipstls_runtime_arg0() string { return boring_runtime_arg0() }
+
+//go:linkname crypto_backend_runtime_arg0 crypto/internal/backend.runtime_arg0
+func crypto_backend_runtime_arg0() string {
+	return boring_runtime_arg0()
+}
